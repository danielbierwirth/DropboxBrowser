///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

/// Arguments, results, and errors for the `Files` namespace.

#import "DBFILESLookupError.h"
#import "DBFILESPropertiesError.h"
#import "DBPROPERTIESPropertyTemplateError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESPropertiesError

@synthesize templateNotFound = _templateNotFound;
@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithTemplateNotFound:(NSString *)templateNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESPropertiesErrorTemplateNotFound;
    _templateNotFound = templateNotFound;
  }
  return self;
}

- (instancetype)initWithRestrictedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESPropertiesErrorRestrictedContent;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESPropertiesErrorOther;
  }
  return self;
}

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESPropertiesErrorPath;
    _path = path;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)templateNotFound {
  if (![self isTemplateNotFound]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESPropertiesErrorTemplateNotFound, but was %@.", [self tagName]];
  }
  return _templateNotFound;
}

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESPropertiesErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isTemplateNotFound {
  return _tag == DBFILESPropertiesErrorTemplateNotFound;
}

- (BOOL)isRestrictedContent {
  return _tag == DBFILESPropertiesErrorRestrictedContent;
}

- (BOOL)isOther {
  return _tag == DBFILESPropertiesErrorOther;
}

- (BOOL)isPath {
  return _tag == DBFILESPropertiesErrorPath;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESPropertiesErrorTemplateNotFound:
    return @"DBFILESPropertiesErrorTemplateNotFound";
  case DBFILESPropertiesErrorRestrictedContent:
    return @"DBFILESPropertiesErrorRestrictedContent";
  case DBFILESPropertiesErrorOther:
    return @"DBFILESPropertiesErrorOther";
  case DBFILESPropertiesErrorPath:
    return @"DBFILESPropertiesErrorPath";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESPropertiesErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESPropertiesErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESPropertiesErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESPropertiesErrorTemplateNotFound:
    result = prime * result + [self.templateNotFound hash];
  case DBFILESPropertiesErrorRestrictedContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESPropertiesErrorOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESPropertiesErrorPath:
    result = prime * result + [self.path hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToPropertiesError:other];
}

- (BOOL)isEqualToPropertiesError:(DBFILESPropertiesError *)aPropertiesError {
  if (self == aPropertiesError) {
    return YES;
  }
  if (self.tag != aPropertiesError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESPropertiesErrorTemplateNotFound:
    return [self.templateNotFound isEqual:aPropertiesError.templateNotFound];
  case DBFILESPropertiesErrorRestrictedContent:
    return [[self tagName] isEqual:[aPropertiesError tagName]];
  case DBFILESPropertiesErrorOther:
    return [[self tagName] isEqual:[aPropertiesError tagName]];
  case DBFILESPropertiesErrorPath:
    return [self.path isEqual:aPropertiesError.path];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESPropertiesErrorSerializer

+ (NSDictionary *)serialize:(DBFILESPropertiesError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isTemplateNotFound]) {
    jsonDict[@"template_not_found"] = valueObj.templateNotFound;
    jsonDict[@".tag"] = @"template_not_found";
  } else if ([valueObj isRestrictedContent]) {
    jsonDict[@".tag"] = @"restricted_content";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESPropertiesError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"template_not_found"]) {
    NSString *templateNotFound = valueDict[@"template_not_found"];
    return [[DBFILESPropertiesError alloc] initWithTemplateNotFound:templateNotFound];
  } else if ([tag isEqualToString:@"restricted_content"]) {
    return [[DBFILESPropertiesError alloc] initWithRestrictedContent];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESPropertiesError alloc] initWithOther];
  } else if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESPropertiesError alloc] initWithPath:path];
  } else {
    return [[DBFILESPropertiesError alloc] initWithOther];
  }
}

@end

#import "DBFILESInvalidPropertyGroupError.h"
#import "DBFILESLookupError.h"
#import "DBFILESPropertiesError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESInvalidPropertyGroupError

@synthesize templateNotFound = _templateNotFound;
@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithTemplateNotFound:(NSString *)templateNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESInvalidPropertyGroupErrorTemplateNotFound;
    _templateNotFound = templateNotFound;
  }
  return self;
}

- (instancetype)initWithRestrictedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESInvalidPropertyGroupErrorRestrictedContent;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESInvalidPropertyGroupErrorOther;
  }
  return self;
}

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESInvalidPropertyGroupErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithPropertyFieldTooLarge {
  self = [super init];
  if (self) {
    _tag = DBFILESInvalidPropertyGroupErrorPropertyFieldTooLarge;
  }
  return self;
}

- (instancetype)initWithDoesNotFitTemplate {
  self = [super init];
  if (self) {
    _tag = DBFILESInvalidPropertyGroupErrorDoesNotFitTemplate;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)templateNotFound {
  if (![self isTemplateNotFound]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESInvalidPropertyGroupErrorTemplateNotFound, but was %@.", [self tagName]];
  }
  return _templateNotFound;
}

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESInvalidPropertyGroupErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isTemplateNotFound {
  return _tag == DBFILESInvalidPropertyGroupErrorTemplateNotFound;
}

- (BOOL)isRestrictedContent {
  return _tag == DBFILESInvalidPropertyGroupErrorRestrictedContent;
}

- (BOOL)isOther {
  return _tag == DBFILESInvalidPropertyGroupErrorOther;
}

- (BOOL)isPath {
  return _tag == DBFILESInvalidPropertyGroupErrorPath;
}

- (BOOL)isPropertyFieldTooLarge {
  return _tag == DBFILESInvalidPropertyGroupErrorPropertyFieldTooLarge;
}

- (BOOL)isDoesNotFitTemplate {
  return _tag == DBFILESInvalidPropertyGroupErrorDoesNotFitTemplate;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESInvalidPropertyGroupErrorTemplateNotFound:
    return @"DBFILESInvalidPropertyGroupErrorTemplateNotFound";
  case DBFILESInvalidPropertyGroupErrorRestrictedContent:
    return @"DBFILESInvalidPropertyGroupErrorRestrictedContent";
  case DBFILESInvalidPropertyGroupErrorOther:
    return @"DBFILESInvalidPropertyGroupErrorOther";
  case DBFILESInvalidPropertyGroupErrorPath:
    return @"DBFILESInvalidPropertyGroupErrorPath";
  case DBFILESInvalidPropertyGroupErrorPropertyFieldTooLarge:
    return @"DBFILESInvalidPropertyGroupErrorPropertyFieldTooLarge";
  case DBFILESInvalidPropertyGroupErrorDoesNotFitTemplate:
    return @"DBFILESInvalidPropertyGroupErrorDoesNotFitTemplate";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESInvalidPropertyGroupErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESInvalidPropertyGroupErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESInvalidPropertyGroupErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESInvalidPropertyGroupErrorTemplateNotFound:
    result = prime * result + [self.templateNotFound hash];
  case DBFILESInvalidPropertyGroupErrorRestrictedContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESInvalidPropertyGroupErrorOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESInvalidPropertyGroupErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESInvalidPropertyGroupErrorPropertyFieldTooLarge:
    result = prime * result + [[self tagName] hash];
  case DBFILESInvalidPropertyGroupErrorDoesNotFitTemplate:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToInvalidPropertyGroupError:other];
}

- (BOOL)isEqualToInvalidPropertyGroupError:(DBFILESInvalidPropertyGroupError *)anInvalidPropertyGroupError {
  if (self == anInvalidPropertyGroupError) {
    return YES;
  }
  if (self.tag != anInvalidPropertyGroupError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESInvalidPropertyGroupErrorTemplateNotFound:
    return [self.templateNotFound isEqual:anInvalidPropertyGroupError.templateNotFound];
  case DBFILESInvalidPropertyGroupErrorRestrictedContent:
    return [[self tagName] isEqual:[anInvalidPropertyGroupError tagName]];
  case DBFILESInvalidPropertyGroupErrorOther:
    return [[self tagName] isEqual:[anInvalidPropertyGroupError tagName]];
  case DBFILESInvalidPropertyGroupErrorPath:
    return [self.path isEqual:anInvalidPropertyGroupError.path];
  case DBFILESInvalidPropertyGroupErrorPropertyFieldTooLarge:
    return [[self tagName] isEqual:[anInvalidPropertyGroupError tagName]];
  case DBFILESInvalidPropertyGroupErrorDoesNotFitTemplate:
    return [[self tagName] isEqual:[anInvalidPropertyGroupError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESInvalidPropertyGroupErrorSerializer

+ (NSDictionary *)serialize:(DBFILESInvalidPropertyGroupError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isTemplateNotFound]) {
    jsonDict[@"template_not_found"] = valueObj.templateNotFound;
    jsonDict[@".tag"] = @"template_not_found";
  } else if ([valueObj isRestrictedContent]) {
    jsonDict[@".tag"] = @"restricted_content";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isPropertyFieldTooLarge]) {
    jsonDict[@".tag"] = @"property_field_too_large";
  } else if ([valueObj isDoesNotFitTemplate]) {
    jsonDict[@".tag"] = @"does_not_fit_template";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESInvalidPropertyGroupError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"template_not_found"]) {
    NSString *templateNotFound = valueDict[@"template_not_found"];
    return [[DBFILESInvalidPropertyGroupError alloc] initWithTemplateNotFound:templateNotFound];
  } else if ([tag isEqualToString:@"restricted_content"]) {
    return [[DBFILESInvalidPropertyGroupError alloc] initWithRestrictedContent];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESInvalidPropertyGroupError alloc] initWithOther];
  } else if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESInvalidPropertyGroupError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"property_field_too_large"]) {
    return [[DBFILESInvalidPropertyGroupError alloc] initWithPropertyFieldTooLarge];
  } else if ([tag isEqualToString:@"does_not_fit_template"]) {
    return [[DBFILESInvalidPropertyGroupError alloc] initWithDoesNotFitTemplate];
  } else {
    return [[DBFILESInvalidPropertyGroupError alloc] initWithOther];
  }
}

@end

#import "DBFILESAddPropertiesError.h"
#import "DBFILESInvalidPropertyGroupError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESAddPropertiesError

@synthesize templateNotFound = _templateNotFound;
@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithTemplateNotFound:(NSString *)templateNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorTemplateNotFound;
    _templateNotFound = templateNotFound;
  }
  return self;
}

- (instancetype)initWithRestrictedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorRestrictedContent;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorOther;
  }
  return self;
}

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithPropertyFieldTooLarge {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorPropertyFieldTooLarge;
  }
  return self;
}

- (instancetype)initWithDoesNotFitTemplate {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorDoesNotFitTemplate;
  }
  return self;
}

- (instancetype)initWithPropertyGroupAlreadyExists {
  self = [super init];
  if (self) {
    _tag = DBFILESAddPropertiesErrorPropertyGroupAlreadyExists;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)templateNotFound {
  if (![self isTemplateNotFound]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESAddPropertiesErrorTemplateNotFound, but was %@.", [self tagName]];
  }
  return _templateNotFound;
}

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESAddPropertiesErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isTemplateNotFound {
  return _tag == DBFILESAddPropertiesErrorTemplateNotFound;
}

- (BOOL)isRestrictedContent {
  return _tag == DBFILESAddPropertiesErrorRestrictedContent;
}

- (BOOL)isOther {
  return _tag == DBFILESAddPropertiesErrorOther;
}

- (BOOL)isPath {
  return _tag == DBFILESAddPropertiesErrorPath;
}

- (BOOL)isPropertyFieldTooLarge {
  return _tag == DBFILESAddPropertiesErrorPropertyFieldTooLarge;
}

- (BOOL)isDoesNotFitTemplate {
  return _tag == DBFILESAddPropertiesErrorDoesNotFitTemplate;
}

- (BOOL)isPropertyGroupAlreadyExists {
  return _tag == DBFILESAddPropertiesErrorPropertyGroupAlreadyExists;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESAddPropertiesErrorTemplateNotFound:
    return @"DBFILESAddPropertiesErrorTemplateNotFound";
  case DBFILESAddPropertiesErrorRestrictedContent:
    return @"DBFILESAddPropertiesErrorRestrictedContent";
  case DBFILESAddPropertiesErrorOther:
    return @"DBFILESAddPropertiesErrorOther";
  case DBFILESAddPropertiesErrorPath:
    return @"DBFILESAddPropertiesErrorPath";
  case DBFILESAddPropertiesErrorPropertyFieldTooLarge:
    return @"DBFILESAddPropertiesErrorPropertyFieldTooLarge";
  case DBFILESAddPropertiesErrorDoesNotFitTemplate:
    return @"DBFILESAddPropertiesErrorDoesNotFitTemplate";
  case DBFILESAddPropertiesErrorPropertyGroupAlreadyExists:
    return @"DBFILESAddPropertiesErrorPropertyGroupAlreadyExists";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESAddPropertiesErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESAddPropertiesErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESAddPropertiesErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESAddPropertiesErrorTemplateNotFound:
    result = prime * result + [self.templateNotFound hash];
  case DBFILESAddPropertiesErrorRestrictedContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESAddPropertiesErrorOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESAddPropertiesErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESAddPropertiesErrorPropertyFieldTooLarge:
    result = prime * result + [[self tagName] hash];
  case DBFILESAddPropertiesErrorDoesNotFitTemplate:
    result = prime * result + [[self tagName] hash];
  case DBFILESAddPropertiesErrorPropertyGroupAlreadyExists:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToAddPropertiesError:other];
}

- (BOOL)isEqualToAddPropertiesError:(DBFILESAddPropertiesError *)anAddPropertiesError {
  if (self == anAddPropertiesError) {
    return YES;
  }
  if (self.tag != anAddPropertiesError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESAddPropertiesErrorTemplateNotFound:
    return [self.templateNotFound isEqual:anAddPropertiesError.templateNotFound];
  case DBFILESAddPropertiesErrorRestrictedContent:
    return [[self tagName] isEqual:[anAddPropertiesError tagName]];
  case DBFILESAddPropertiesErrorOther:
    return [[self tagName] isEqual:[anAddPropertiesError tagName]];
  case DBFILESAddPropertiesErrorPath:
    return [self.path isEqual:anAddPropertiesError.path];
  case DBFILESAddPropertiesErrorPropertyFieldTooLarge:
    return [[self tagName] isEqual:[anAddPropertiesError tagName]];
  case DBFILESAddPropertiesErrorDoesNotFitTemplate:
    return [[self tagName] isEqual:[anAddPropertiesError tagName]];
  case DBFILESAddPropertiesErrorPropertyGroupAlreadyExists:
    return [[self tagName] isEqual:[anAddPropertiesError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESAddPropertiesErrorSerializer

+ (NSDictionary *)serialize:(DBFILESAddPropertiesError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isTemplateNotFound]) {
    jsonDict[@"template_not_found"] = valueObj.templateNotFound;
    jsonDict[@".tag"] = @"template_not_found";
  } else if ([valueObj isRestrictedContent]) {
    jsonDict[@".tag"] = @"restricted_content";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isPropertyFieldTooLarge]) {
    jsonDict[@".tag"] = @"property_field_too_large";
  } else if ([valueObj isDoesNotFitTemplate]) {
    jsonDict[@".tag"] = @"does_not_fit_template";
  } else if ([valueObj isPropertyGroupAlreadyExists]) {
    jsonDict[@".tag"] = @"property_group_already_exists";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESAddPropertiesError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"template_not_found"]) {
    NSString *templateNotFound = valueDict[@"template_not_found"];
    return [[DBFILESAddPropertiesError alloc] initWithTemplateNotFound:templateNotFound];
  } else if ([tag isEqualToString:@"restricted_content"]) {
    return [[DBFILESAddPropertiesError alloc] initWithRestrictedContent];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESAddPropertiesError alloc] initWithOther];
  } else if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESAddPropertiesError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"property_field_too_large"]) {
    return [[DBFILESAddPropertiesError alloc] initWithPropertyFieldTooLarge];
  } else if ([tag isEqualToString:@"does_not_fit_template"]) {
    return [[DBFILESAddPropertiesError alloc] initWithDoesNotFitTemplate];
  } else if ([tag isEqualToString:@"property_group_already_exists"]) {
    return [[DBFILESAddPropertiesError alloc] initWithPropertyGroupAlreadyExists];
  } else {
    return [[DBFILESAddPropertiesError alloc] initWithOther];
  }
}

@end

#import "DBFILESGetMetadataArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetMetadataArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                   includeMediaInfo:(NSNumber *)includeMediaInfo
                     includeDeleted:(NSNumber *)includeDeleted
    includeHasExplicitSharedMembers:(NSNumber *)includeHasExplicitSharedMembers {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
    _includeMediaInfo = includeMediaInfo ?: @NO;
    _includeDeleted = includeDeleted ?: @NO;
    _includeHasExplicitSharedMembers = includeHasExplicitSharedMembers ?: @NO;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path includeMediaInfo:nil includeDeleted:nil includeHasExplicitSharedMembers:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetMetadataArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetMetadataArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetMetadataArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.includeMediaInfo hash];
  result = prime * result + [self.includeDeleted hash];
  result = prime * result + [self.includeHasExplicitSharedMembers hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetMetadataArg:other];
}

- (BOOL)isEqualToGetMetadataArg:(DBFILESGetMetadataArg *)aGetMetadataArg {
  if (self == aGetMetadataArg) {
    return YES;
  }
  if (![self.path isEqual:aGetMetadataArg.path]) {
    return NO;
  }
  if (![self.includeMediaInfo isEqual:aGetMetadataArg.includeMediaInfo]) {
    return NO;
  }
  if (![self.includeDeleted isEqual:aGetMetadataArg.includeDeleted]) {
    return NO;
  }
  if (![self.includeHasExplicitSharedMembers isEqual:aGetMetadataArg.includeHasExplicitSharedMembers]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetMetadataArgSerializer

+ (NSDictionary *)serialize:(DBFILESGetMetadataArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"include_media_info"] = valueObj.includeMediaInfo;
  jsonDict[@"include_deleted"] = valueObj.includeDeleted;
  jsonDict[@"include_has_explicit_shared_members"] = valueObj.includeHasExplicitSharedMembers;

  return jsonDict;
}

+ (DBFILESGetMetadataArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSNumber *includeMediaInfo = valueDict[@"include_media_info"] ?: @NO;
  NSNumber *includeDeleted = valueDict[@"include_deleted"] ?: @NO;
  NSNumber *includeHasExplicitSharedMembers = valueDict[@"include_has_explicit_shared_members"] ?: @NO;

  return [[DBFILESGetMetadataArg alloc] initWithPath:path
                                    includeMediaInfo:includeMediaInfo
                                      includeDeleted:includeDeleted
                     includeHasExplicitSharedMembers:includeHasExplicitSharedMembers];
}

@end

#import "DBFILESAlphaGetMetadataArg.h"
#import "DBFILESGetMetadataArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESAlphaGetMetadataArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                   includeMediaInfo:(NSNumber *)includeMediaInfo
                     includeDeleted:(NSNumber *)includeDeleted
    includeHasExplicitSharedMembers:(NSNumber *)includeHasExplicitSharedMembers
           includePropertyTemplates:(NSArray<NSString *> *)includePropertyTemplates {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators
                         arrayValidator:nil
                               maxItems:nil
                          itemValidator:[DBStoneValidators stringValidator:@(1) maxLength:nil pattern:@"(/|ptid:).*"]]](
      includePropertyTemplates);

  self = [super initWithPath:path
                     includeMediaInfo:includeMediaInfo
                       includeDeleted:includeDeleted
      includeHasExplicitSharedMembers:includeHasExplicitSharedMembers];
  if (self) {
    _includePropertyTemplates = includePropertyTemplates;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path
                     includeMediaInfo:nil
                       includeDeleted:nil
      includeHasExplicitSharedMembers:nil
             includePropertyTemplates:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESAlphaGetMetadataArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESAlphaGetMetadataArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESAlphaGetMetadataArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.includeMediaInfo hash];
  result = prime * result + [self.includeDeleted hash];
  result = prime * result + [self.includeHasExplicitSharedMembers hash];
  if (self.includePropertyTemplates) {
    result = prime * result + [self.includePropertyTemplates hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToAlphaGetMetadataArg:other];
}

- (BOOL)isEqualToAlphaGetMetadataArg:(DBFILESAlphaGetMetadataArg *)anAlphaGetMetadataArg {
  if (self == anAlphaGetMetadataArg) {
    return YES;
  }
  if (![self.path isEqual:anAlphaGetMetadataArg.path]) {
    return NO;
  }
  if (![self.includeMediaInfo isEqual:anAlphaGetMetadataArg.includeMediaInfo]) {
    return NO;
  }
  if (![self.includeDeleted isEqual:anAlphaGetMetadataArg.includeDeleted]) {
    return NO;
  }
  if (![self.includeHasExplicitSharedMembers isEqual:anAlphaGetMetadataArg.includeHasExplicitSharedMembers]) {
    return NO;
  }
  if (self.includePropertyTemplates) {
    if (![self.includePropertyTemplates isEqual:anAlphaGetMetadataArg.includePropertyTemplates]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESAlphaGetMetadataArgSerializer

+ (NSDictionary *)serialize:(DBFILESAlphaGetMetadataArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"include_media_info"] = valueObj.includeMediaInfo;
  jsonDict[@"include_deleted"] = valueObj.includeDeleted;
  jsonDict[@"include_has_explicit_shared_members"] = valueObj.includeHasExplicitSharedMembers;
  if (valueObj.includePropertyTemplates) {
    jsonDict[@"include_property_templates"] = [DBArraySerializer serialize:valueObj.includePropertyTemplates
                                                                 withBlock:^id(id elem0) {
                                                                   return elem0;
                                                                 }];
  }

  return jsonDict;
}

+ (DBFILESAlphaGetMetadataArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSNumber *includeMediaInfo = valueDict[@"include_media_info"] ?: @NO;
  NSNumber *includeDeleted = valueDict[@"include_deleted"] ?: @NO;
  NSNumber *includeHasExplicitSharedMembers = valueDict[@"include_has_explicit_shared_members"] ?: @NO;
  NSArray<NSString *> *includePropertyTemplates =
      valueDict[@"include_property_templates"] ? [DBArraySerializer deserialize:valueDict[@"include_property_templates"]
                                                                      withBlock:^id(id elem0) {
                                                                        return elem0;
                                                                      }]
                                               : nil;

  return [[DBFILESAlphaGetMetadataArg alloc] initWithPath:path
                                         includeMediaInfo:includeMediaInfo
                                           includeDeleted:includeDeleted
                          includeHasExplicitSharedMembers:includeHasExplicitSharedMembers
                                 includePropertyTemplates:includePropertyTemplates];
}

@end

#import "DBFILESGetMetadataError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetMetadataError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESGetMetadataErrorPath;
    _path = path;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESGetMetadataErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESGetMetadataErrorPath;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESGetMetadataErrorPath:
    return @"DBFILESGetMetadataErrorPath";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetMetadataErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetMetadataErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetMetadataErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESGetMetadataErrorPath:
    result = prime * result + [self.path hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetMetadataError:other];
}

- (BOOL)isEqualToGetMetadataError:(DBFILESGetMetadataError *)aGetMetadataError {
  if (self == aGetMetadataError) {
    return YES;
  }
  if (self.tag != aGetMetadataError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESGetMetadataErrorPath:
    return [self.path isEqual:aGetMetadataError.path];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetMetadataErrorSerializer

+ (NSDictionary *)serialize:(DBFILESGetMetadataError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESGetMetadataError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESGetMetadataError alloc] initWithPath:path];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESAlphaGetMetadataError.h"
#import "DBFILESGetMetadataError.h"
#import "DBFILESLookUpPropertiesError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESAlphaGetMetadataError

@synthesize path = _path;
@synthesize propertiesError = _propertiesError;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESAlphaGetMetadataErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithPropertiesError:(DBFILESLookUpPropertiesError *)propertiesError {
  self = [super init];
  if (self) {
    _tag = DBFILESAlphaGetMetadataErrorPropertiesError;
    _propertiesError = propertiesError;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESAlphaGetMetadataErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

- (DBFILESLookUpPropertiesError *)propertiesError {
  if (![self isPropertiesError]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESAlphaGetMetadataErrorPropertiesError, but was %@.", [self tagName]];
  }
  return _propertiesError;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESAlphaGetMetadataErrorPath;
}

- (BOOL)isPropertiesError {
  return _tag == DBFILESAlphaGetMetadataErrorPropertiesError;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESAlphaGetMetadataErrorPath:
    return @"DBFILESAlphaGetMetadataErrorPath";
  case DBFILESAlphaGetMetadataErrorPropertiesError:
    return @"DBFILESAlphaGetMetadataErrorPropertiesError";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESAlphaGetMetadataErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESAlphaGetMetadataErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESAlphaGetMetadataErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESAlphaGetMetadataErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESAlphaGetMetadataErrorPropertiesError:
    result = prime * result + [self.propertiesError hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToAlphaGetMetadataError:other];
}

- (BOOL)isEqualToAlphaGetMetadataError:(DBFILESAlphaGetMetadataError *)anAlphaGetMetadataError {
  if (self == anAlphaGetMetadataError) {
    return YES;
  }
  if (self.tag != anAlphaGetMetadataError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESAlphaGetMetadataErrorPath:
    return [self.path isEqual:anAlphaGetMetadataError.path];
  case DBFILESAlphaGetMetadataErrorPropertiesError:
    return [self.propertiesError isEqual:anAlphaGetMetadataError.propertiesError];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESAlphaGetMetadataErrorSerializer

+ (NSDictionary *)serialize:(DBFILESAlphaGetMetadataError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isPropertiesError]) {
    jsonDict[@"properties_error"] =
        [[DBFILESLookUpPropertiesErrorSerializer serialize:valueObj.propertiesError] mutableCopy];
    jsonDict[@".tag"] = @"properties_error";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESAlphaGetMetadataError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESAlphaGetMetadataError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"properties_error"]) {
    DBFILESLookUpPropertiesError *propertiesError =
        [DBFILESLookUpPropertiesErrorSerializer deserialize:valueDict[@"properties_error"]];
    return [[DBFILESAlphaGetMetadataError alloc] initWithPropertiesError:propertiesError];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESCommitInfo.h"
#import "DBFILESWriteMode.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESCommitInfo

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                        mode:(DBFILESWriteMode *)mode
                  autorename:(NSNumber *)autorename
              clientModified:(NSDate *)clientModified
                        mute:(NSNumber *)mute {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
    _mode = mode ?: [[DBFILESWriteMode alloc] initWithAdd];
    _autorename = autorename ?: @NO;
    _clientModified = clientModified;
    _mute = mute ?: @NO;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path mode:nil autorename:nil clientModified:nil mute:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESCommitInfoSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESCommitInfoSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESCommitInfoSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.mode hash];
  result = prime * result + [self.autorename hash];
  if (self.clientModified) {
    result = prime * result + [self.clientModified hash];
  }
  result = prime * result + [self.mute hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToCommitInfo:other];
}

- (BOOL)isEqualToCommitInfo:(DBFILESCommitInfo *)aCommitInfo {
  if (self == aCommitInfo) {
    return YES;
  }
  if (![self.path isEqual:aCommitInfo.path]) {
    return NO;
  }
  if (![self.mode isEqual:aCommitInfo.mode]) {
    return NO;
  }
  if (![self.autorename isEqual:aCommitInfo.autorename]) {
    return NO;
  }
  if (self.clientModified) {
    if (![self.clientModified isEqual:aCommitInfo.clientModified]) {
      return NO;
    }
  }
  if (![self.mute isEqual:aCommitInfo.mute]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESCommitInfoSerializer

+ (NSDictionary *)serialize:(DBFILESCommitInfo *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"mode"] = [DBFILESWriteModeSerializer serialize:valueObj.mode];
  jsonDict[@"autorename"] = valueObj.autorename;
  if (valueObj.clientModified) {
    jsonDict[@"client_modified"] =
        [DBNSDateSerializer serialize:valueObj.clientModified dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  }
  jsonDict[@"mute"] = valueObj.mute;

  return jsonDict;
}

+ (DBFILESCommitInfo *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  DBFILESWriteMode *mode = valueDict[@"mode"] ? [DBFILESWriteModeSerializer deserialize:valueDict[@"mode"]]
                                              : [[DBFILESWriteMode alloc] initWithAdd];
  NSNumber *autorename = valueDict[@"autorename"] ?: @NO;
  NSDate *clientModified = valueDict[@"client_modified"] ? [DBNSDateSerializer deserialize:valueDict[@"client_modified"]
                                                                                dateFormat:@"%Y-%m-%dT%H:%M:%SZ"]
                                                         : nil;
  NSNumber *mute = valueDict[@"mute"] ?: @NO;

  return [[DBFILESCommitInfo alloc] initWithPath:path
                                            mode:mode
                                      autorename:autorename
                                  clientModified:clientModified
                                            mute:mute];
}

@end

#import "DBFILESCommitInfo.h"
#import "DBFILESCommitInfoWithProperties.h"
#import "DBFILESWriteMode.h"
#import "DBPROPERTIESPropertyGroup.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESCommitInfoWithProperties

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                        mode:(DBFILESWriteMode *)mode
                  autorename:(NSNumber *)autorename
              clientModified:(NSDate *)clientModified
                        mute:(NSNumber *)mute
              propertyGroups:(NSArray<DBPROPERTIESPropertyGroup *> *)propertyGroups {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil]](propertyGroups);

  self = [super initWithPath:path mode:mode autorename:autorename clientModified:clientModified mute:mute];
  if (self) {
    _propertyGroups = propertyGroups;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path mode:nil autorename:nil clientModified:nil mute:nil propertyGroups:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESCommitInfoWithPropertiesSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESCommitInfoWithPropertiesSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESCommitInfoWithPropertiesSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.mode hash];
  result = prime * result + [self.autorename hash];
  if (self.clientModified) {
    result = prime * result + [self.clientModified hash];
  }
  result = prime * result + [self.mute hash];
  if (self.propertyGroups) {
    result = prime * result + [self.propertyGroups hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToCommitInfoWithProperties:other];
}

- (BOOL)isEqualToCommitInfoWithProperties:(DBFILESCommitInfoWithProperties *)aCommitInfoWithProperties {
  if (self == aCommitInfoWithProperties) {
    return YES;
  }
  if (![self.path isEqual:aCommitInfoWithProperties.path]) {
    return NO;
  }
  if (![self.mode isEqual:aCommitInfoWithProperties.mode]) {
    return NO;
  }
  if (![self.autorename isEqual:aCommitInfoWithProperties.autorename]) {
    return NO;
  }
  if (self.clientModified) {
    if (![self.clientModified isEqual:aCommitInfoWithProperties.clientModified]) {
      return NO;
    }
  }
  if (![self.mute isEqual:aCommitInfoWithProperties.mute]) {
    return NO;
  }
  if (self.propertyGroups) {
    if (![self.propertyGroups isEqual:aCommitInfoWithProperties.propertyGroups]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESCommitInfoWithPropertiesSerializer

+ (NSDictionary *)serialize:(DBFILESCommitInfoWithProperties *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"mode"] = [DBFILESWriteModeSerializer serialize:valueObj.mode];
  jsonDict[@"autorename"] = valueObj.autorename;
  if (valueObj.clientModified) {
    jsonDict[@"client_modified"] =
        [DBNSDateSerializer serialize:valueObj.clientModified dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  }
  jsonDict[@"mute"] = valueObj.mute;
  if (valueObj.propertyGroups) {
    jsonDict[@"property_groups"] = [DBArraySerializer serialize:valueObj.propertyGroups
                                                      withBlock:^id(id elem0) {
                                                        return [DBPROPERTIESPropertyGroupSerializer serialize:elem0];
                                                      }];
  }

  return jsonDict;
}

+ (DBFILESCommitInfoWithProperties *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  DBFILESWriteMode *mode = valueDict[@"mode"] ? [DBFILESWriteModeSerializer deserialize:valueDict[@"mode"]]
                                              : [[DBFILESWriteMode alloc] initWithAdd];
  NSNumber *autorename = valueDict[@"autorename"] ?: @NO;
  NSDate *clientModified = valueDict[@"client_modified"] ? [DBNSDateSerializer deserialize:valueDict[@"client_modified"]
                                                                                dateFormat:@"%Y-%m-%dT%H:%M:%SZ"]
                                                         : nil;
  NSNumber *mute = valueDict[@"mute"] ?: @NO;
  NSArray<DBPROPERTIESPropertyGroup *> *propertyGroups =
      valueDict[@"property_groups"]
          ? [DBArraySerializer deserialize:valueDict[@"property_groups"]
                                 withBlock:^id(id elem0) {
                                   return [DBPROPERTIESPropertyGroupSerializer deserialize:elem0];
                                 }]
          : nil;

  return [[DBFILESCommitInfoWithProperties alloc] initWithPath:path
                                                          mode:mode
                                                    autorename:autorename
                                                clientModified:clientModified
                                                          mute:mute
                                                propertyGroups:propertyGroups];
}

@end

#import "DBFILESCreateFolderArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESCreateFolderArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path autorename:(NSNumber *)autorename {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
    _autorename = autorename ?: @NO;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path autorename:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESCreateFolderArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESCreateFolderArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESCreateFolderArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.autorename hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToCreateFolderArg:other];
}

- (BOOL)isEqualToCreateFolderArg:(DBFILESCreateFolderArg *)aCreateFolderArg {
  if (self == aCreateFolderArg) {
    return YES;
  }
  if (![self.path isEqual:aCreateFolderArg.path]) {
    return NO;
  }
  if (![self.autorename isEqual:aCreateFolderArg.autorename]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESCreateFolderArgSerializer

+ (NSDictionary *)serialize:(DBFILESCreateFolderArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"autorename"] = valueObj.autorename;

  return jsonDict;
}

+ (DBFILESCreateFolderArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSNumber *autorename = valueDict[@"autorename"] ?: @NO;

  return [[DBFILESCreateFolderArg alloc] initWithPath:path autorename:autorename];
}

@end

#import "DBFILESCreateFolderError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESCreateFolderError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESWriteError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESCreateFolderErrorPath;
    _path = path;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESWriteError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESCreateFolderErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESCreateFolderErrorPath;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESCreateFolderErrorPath:
    return @"DBFILESCreateFolderErrorPath";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESCreateFolderErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESCreateFolderErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESCreateFolderErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESCreateFolderErrorPath:
    result = prime * result + [self.path hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToCreateFolderError:other];
}

- (BOOL)isEqualToCreateFolderError:(DBFILESCreateFolderError *)aCreateFolderError {
  if (self == aCreateFolderError) {
    return YES;
  }
  if (self.tag != aCreateFolderError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESCreateFolderErrorPath:
    return [self.path isEqual:aCreateFolderError.path];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESCreateFolderErrorSerializer

+ (NSDictionary *)serialize:(DBFILESCreateFolderError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESWriteErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESCreateFolderError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESWriteError *path = [DBFILESWriteErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESCreateFolderError alloc] initWithPath:path];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESDeleteArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteArg:other];
}

- (BOOL)isEqualToDeleteArg:(DBFILESDeleteArg *)aDeleteArg {
  if (self == aDeleteArg) {
    return YES;
  }
  if (![self.path isEqual:aDeleteArg.path]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteArgSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;

  return jsonDict;
}

+ (DBFILESDeleteArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];

  return [[DBFILESDeleteArg alloc] initWithPath:path];
}

@end

#import "DBFILESDeleteArg.h"
#import "DBFILESDeleteBatchArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteBatchArg

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESDeleteArg *> *)entries {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _entries = entries;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteBatchArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteBatchArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteBatchArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteBatchArg:other];
}

- (BOOL)isEqualToDeleteBatchArg:(DBFILESDeleteBatchArg *)aDeleteBatchArg {
  if (self == aDeleteBatchArg) {
    return YES;
  }
  if (![self.entries isEqual:aDeleteBatchArg.entries]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteBatchArgSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteBatchArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESDeleteArgSerializer serialize:elem0];
                                            }];

  return jsonDict;
}

+ (DBFILESDeleteBatchArg *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESDeleteArg *> *entries = [DBArraySerializer deserialize:valueDict[@"entries"]
                                                              withBlock:^id(id elem0) {
                                                                return [DBFILESDeleteArgSerializer deserialize:elem0];
                                                              }];

  return [[DBFILESDeleteBatchArg alloc] initWithEntries:entries];
}

@end

#import "DBFILESDeleteBatchError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteBatchError

#pragma mark - Constructors

- (instancetype)initWithTooManyWriteOperations {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchErrorTooManyWriteOperations;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isTooManyWriteOperations {
  return _tag == DBFILESDeleteBatchErrorTooManyWriteOperations;
}

- (BOOL)isOther {
  return _tag == DBFILESDeleteBatchErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESDeleteBatchErrorTooManyWriteOperations:
    return @"DBFILESDeleteBatchErrorTooManyWriteOperations";
  case DBFILESDeleteBatchErrorOther:
    return @"DBFILESDeleteBatchErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteBatchErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteBatchErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteBatchErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESDeleteBatchErrorTooManyWriteOperations:
    result = prime * result + [[self tagName] hash];
  case DBFILESDeleteBatchErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteBatchError:other];
}

- (BOOL)isEqualToDeleteBatchError:(DBFILESDeleteBatchError *)aDeleteBatchError {
  if (self == aDeleteBatchError) {
    return YES;
  }
  if (self.tag != aDeleteBatchError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESDeleteBatchErrorTooManyWriteOperations:
    return [[self tagName] isEqual:[aDeleteBatchError tagName]];
  case DBFILESDeleteBatchErrorOther:
    return [[self tagName] isEqual:[aDeleteBatchError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteBatchErrorSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteBatchError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isTooManyWriteOperations]) {
    jsonDict[@".tag"] = @"too_many_write_operations";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESDeleteBatchError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"too_many_write_operations"]) {
    return [[DBFILESDeleteBatchError alloc] initWithTooManyWriteOperations];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESDeleteBatchError alloc] initWithOther];
  } else {
    return [[DBFILESDeleteBatchError alloc] initWithOther];
  }
}

@end

#import "DBASYNCPollResultBase.h"
#import "DBFILESDeleteBatchError.h"
#import "DBFILESDeleteBatchJobStatus.h"
#import "DBFILESDeleteBatchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteBatchJobStatus

@synthesize complete = _complete;
@synthesize failed = _failed;

#pragma mark - Constructors

- (instancetype)initWithInProgress {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchJobStatusInProgress;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESDeleteBatchResult *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchJobStatusComplete;
    _complete = complete;
  }
  return self;
}

- (instancetype)initWithFailed:(DBFILESDeleteBatchError *)failed {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchJobStatusFailed;
    _failed = failed;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchJobStatusOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESDeleteBatchResult *)complete {
  if (![self isComplete]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteBatchJobStatusComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

- (DBFILESDeleteBatchError *)failed {
  if (![self isFailed]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteBatchJobStatusFailed, but was %@.", [self tagName]];
  }
  return _failed;
}

#pragma mark - Tag state methods

- (BOOL)isInProgress {
  return _tag == DBFILESDeleteBatchJobStatusInProgress;
}

- (BOOL)isComplete {
  return _tag == DBFILESDeleteBatchJobStatusComplete;
}

- (BOOL)isFailed {
  return _tag == DBFILESDeleteBatchJobStatusFailed;
}

- (BOOL)isOther {
  return _tag == DBFILESDeleteBatchJobStatusOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESDeleteBatchJobStatusInProgress:
    return @"DBFILESDeleteBatchJobStatusInProgress";
  case DBFILESDeleteBatchJobStatusComplete:
    return @"DBFILESDeleteBatchJobStatusComplete";
  case DBFILESDeleteBatchJobStatusFailed:
    return @"DBFILESDeleteBatchJobStatusFailed";
  case DBFILESDeleteBatchJobStatusOther:
    return @"DBFILESDeleteBatchJobStatusOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteBatchJobStatusSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteBatchJobStatusSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteBatchJobStatusSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESDeleteBatchJobStatusInProgress:
    result = prime * result + [[self tagName] hash];
  case DBFILESDeleteBatchJobStatusComplete:
    result = prime * result + [self.complete hash];
  case DBFILESDeleteBatchJobStatusFailed:
    result = prime * result + [self.failed hash];
  case DBFILESDeleteBatchJobStatusOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteBatchJobStatus:other];
}

- (BOOL)isEqualToDeleteBatchJobStatus:(DBFILESDeleteBatchJobStatus *)aDeleteBatchJobStatus {
  if (self == aDeleteBatchJobStatus) {
    return YES;
  }
  if (self.tag != aDeleteBatchJobStatus.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESDeleteBatchJobStatusInProgress:
    return [[self tagName] isEqual:[aDeleteBatchJobStatus tagName]];
  case DBFILESDeleteBatchJobStatusComplete:
    return [self.complete isEqual:aDeleteBatchJobStatus.complete];
  case DBFILESDeleteBatchJobStatusFailed:
    return [self.failed isEqual:aDeleteBatchJobStatus.failed];
  case DBFILESDeleteBatchJobStatusOther:
    return [[self tagName] isEqual:[aDeleteBatchJobStatus tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteBatchJobStatusSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteBatchJobStatus *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isInProgress]) {
    jsonDict[@".tag"] = @"in_progress";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESDeleteBatchResultSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else if ([valueObj isFailed]) {
    jsonDict[@"failed"] = [[DBFILESDeleteBatchErrorSerializer serialize:valueObj.failed] mutableCopy];
    jsonDict[@".tag"] = @"failed";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESDeleteBatchJobStatus *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"in_progress"]) {
    return [[DBFILESDeleteBatchJobStatus alloc] initWithInProgress];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESDeleteBatchResult *complete = [DBFILESDeleteBatchResultSerializer deserialize:valueDict];
    return [[DBFILESDeleteBatchJobStatus alloc] initWithComplete:complete];
  } else if ([tag isEqualToString:@"failed"]) {
    DBFILESDeleteBatchError *failed = [DBFILESDeleteBatchErrorSerializer deserialize:valueDict[@"failed"]];
    return [[DBFILESDeleteBatchJobStatus alloc] initWithFailed:failed];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESDeleteBatchJobStatus alloc] initWithOther];
  } else {
    return [[DBFILESDeleteBatchJobStatus alloc] initWithOther];
  }
}

@end

#import "DBASYNCLaunchResultBase.h"
#import "DBFILESDeleteBatchLaunch.h"
#import "DBFILESDeleteBatchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteBatchLaunch

@synthesize asyncJobId = _asyncJobId;
@synthesize complete = _complete;

#pragma mark - Constructors

- (instancetype)initWithAsyncJobId:(NSString *)asyncJobId {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchLaunchAsyncJobId;
    _asyncJobId = asyncJobId;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESDeleteBatchResult *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchLaunchComplete;
    _complete = complete;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchLaunchOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)asyncJobId {
  if (![self isAsyncJobId]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteBatchLaunchAsyncJobId, but was %@.", [self tagName]];
  }
  return _asyncJobId;
}

- (DBFILESDeleteBatchResult *)complete {
  if (![self isComplete]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteBatchLaunchComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

#pragma mark - Tag state methods

- (BOOL)isAsyncJobId {
  return _tag == DBFILESDeleteBatchLaunchAsyncJobId;
}

- (BOOL)isComplete {
  return _tag == DBFILESDeleteBatchLaunchComplete;
}

- (BOOL)isOther {
  return _tag == DBFILESDeleteBatchLaunchOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESDeleteBatchLaunchAsyncJobId:
    return @"DBFILESDeleteBatchLaunchAsyncJobId";
  case DBFILESDeleteBatchLaunchComplete:
    return @"DBFILESDeleteBatchLaunchComplete";
  case DBFILESDeleteBatchLaunchOther:
    return @"DBFILESDeleteBatchLaunchOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteBatchLaunchSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteBatchLaunchSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteBatchLaunchSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESDeleteBatchLaunchAsyncJobId:
    result = prime * result + [self.asyncJobId hash];
  case DBFILESDeleteBatchLaunchComplete:
    result = prime * result + [self.complete hash];
  case DBFILESDeleteBatchLaunchOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteBatchLaunch:other];
}

- (BOOL)isEqualToDeleteBatchLaunch:(DBFILESDeleteBatchLaunch *)aDeleteBatchLaunch {
  if (self == aDeleteBatchLaunch) {
    return YES;
  }
  if (self.tag != aDeleteBatchLaunch.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESDeleteBatchLaunchAsyncJobId:
    return [self.asyncJobId isEqual:aDeleteBatchLaunch.asyncJobId];
  case DBFILESDeleteBatchLaunchComplete:
    return [self.complete isEqual:aDeleteBatchLaunch.complete];
  case DBFILESDeleteBatchLaunchOther:
    return [[self tagName] isEqual:[aDeleteBatchLaunch tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteBatchLaunchSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteBatchLaunch *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isAsyncJobId]) {
    jsonDict[@"async_job_id"] = valueObj.asyncJobId;
    jsonDict[@".tag"] = @"async_job_id";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESDeleteBatchResultSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESDeleteBatchLaunch *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"async_job_id"]) {
    NSString *asyncJobId = valueDict[@"async_job_id"];
    return [[DBFILESDeleteBatchLaunch alloc] initWithAsyncJobId:asyncJobId];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESDeleteBatchResult *complete = [DBFILESDeleteBatchResultSerializer deserialize:valueDict];
    return [[DBFILESDeleteBatchLaunch alloc] initWithComplete:complete];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESDeleteBatchLaunch alloc] initWithOther];
  } else {
    return [[DBFILESDeleteBatchLaunch alloc] initWithOther];
  }
}

@end

#import "DBFILESDeleteBatchResult.h"
#import "DBFILESDeleteBatchResultEntry.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteBatchResult

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESDeleteBatchResultEntry *> *)entries {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _entries = entries;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteBatchResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteBatchResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteBatchResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteBatchResult:other];
}

- (BOOL)isEqualToDeleteBatchResult:(DBFILESDeleteBatchResult *)aDeleteBatchResult {
  if (self == aDeleteBatchResult) {
    return YES;
  }
  if (![self.entries isEqual:aDeleteBatchResult.entries]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteBatchResultSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteBatchResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESDeleteBatchResultEntrySerializer serialize:elem0];
                                            }];

  return jsonDict;
}

+ (DBFILESDeleteBatchResult *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESDeleteBatchResultEntry *> *entries =
      [DBArraySerializer deserialize:valueDict[@"entries"]
                           withBlock:^id(id elem0) {
                             return [DBFILESDeleteBatchResultEntrySerializer deserialize:elem0];
                           }];

  return [[DBFILESDeleteBatchResult alloc] initWithEntries:entries];
}

@end

#import "DBFILESDeleteBatchResultEntry.h"
#import "DBFILESDeleteError.h"
#import "DBFILESDeleteResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteBatchResultEntry

@synthesize success = _success;
@synthesize failure = _failure;

#pragma mark - Constructors

- (instancetype)initWithSuccess:(DBFILESDeleteResult *)success {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchResultEntrySuccess;
    _success = success;
  }
  return self;
}

- (instancetype)initWithFailure:(DBFILESDeleteError *)failure {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteBatchResultEntryFailure;
    _failure = failure;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESDeleteResult *)success {
  if (![self isSuccess]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteBatchResultEntrySuccess, but was %@.", [self tagName]];
  }
  return _success;
}

- (DBFILESDeleteError *)failure {
  if (![self isFailure]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteBatchResultEntryFailure, but was %@.", [self tagName]];
  }
  return _failure;
}

#pragma mark - Tag state methods

- (BOOL)isSuccess {
  return _tag == DBFILESDeleteBatchResultEntrySuccess;
}

- (BOOL)isFailure {
  return _tag == DBFILESDeleteBatchResultEntryFailure;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESDeleteBatchResultEntrySuccess:
    return @"DBFILESDeleteBatchResultEntrySuccess";
  case DBFILESDeleteBatchResultEntryFailure:
    return @"DBFILESDeleteBatchResultEntryFailure";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteBatchResultEntrySerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteBatchResultEntrySerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteBatchResultEntrySerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESDeleteBatchResultEntrySuccess:
    result = prime * result + [self.success hash];
  case DBFILESDeleteBatchResultEntryFailure:
    result = prime * result + [self.failure hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteBatchResultEntry:other];
}

- (BOOL)isEqualToDeleteBatchResultEntry:(DBFILESDeleteBatchResultEntry *)aDeleteBatchResultEntry {
  if (self == aDeleteBatchResultEntry) {
    return YES;
  }
  if (self.tag != aDeleteBatchResultEntry.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESDeleteBatchResultEntrySuccess:
    return [self.success isEqual:aDeleteBatchResultEntry.success];
  case DBFILESDeleteBatchResultEntryFailure:
    return [self.failure isEqual:aDeleteBatchResultEntry.failure];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteBatchResultEntrySerializer

+ (NSDictionary *)serialize:(DBFILESDeleteBatchResultEntry *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isSuccess]) {
    jsonDict[@"success"] = [[DBFILESDeleteResultSerializer serialize:valueObj.success] mutableCopy];
    jsonDict[@".tag"] = @"success";
  } else if ([valueObj isFailure]) {
    jsonDict[@"failure"] = [[DBFILESDeleteErrorSerializer serialize:valueObj.failure] mutableCopy];
    jsonDict[@".tag"] = @"failure";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESDeleteBatchResultEntry *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"success"]) {
    DBFILESDeleteResult *success = [DBFILESDeleteResultSerializer deserialize:valueDict];
    return [[DBFILESDeleteBatchResultEntry alloc] initWithSuccess:success];
  } else if ([tag isEqualToString:@"failure"]) {
    DBFILESDeleteError *failure = [DBFILESDeleteErrorSerializer deserialize:valueDict[@"failure"]];
    return [[DBFILESDeleteBatchResultEntry alloc] initWithFailure:failure];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESDeleteError.h"
#import "DBFILESLookupError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteError

@synthesize pathLookup = _pathLookup;
@synthesize pathWrite = _pathWrite;

#pragma mark - Constructors

- (instancetype)initWithPathLookup:(DBFILESLookupError *)pathLookup {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteErrorPathLookup;
    _pathLookup = pathLookup;
  }
  return self;
}

- (instancetype)initWithPathWrite:(DBFILESWriteError *)pathWrite {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteErrorPathWrite;
    _pathWrite = pathWrite;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESDeleteErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)pathLookup {
  if (![self isPathLookup]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteErrorPathLookup, but was %@.", [self tagName]];
  }
  return _pathLookup;
}

- (DBFILESWriteError *)pathWrite {
  if (![self isPathWrite]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDeleteErrorPathWrite, but was %@.", [self tagName]];
  }
  return _pathWrite;
}

#pragma mark - Tag state methods

- (BOOL)isPathLookup {
  return _tag == DBFILESDeleteErrorPathLookup;
}

- (BOOL)isPathWrite {
  return _tag == DBFILESDeleteErrorPathWrite;
}

- (BOOL)isOther {
  return _tag == DBFILESDeleteErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESDeleteErrorPathLookup:
    return @"DBFILESDeleteErrorPathLookup";
  case DBFILESDeleteErrorPathWrite:
    return @"DBFILESDeleteErrorPathWrite";
  case DBFILESDeleteErrorOther:
    return @"DBFILESDeleteErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESDeleteErrorPathLookup:
    result = prime * result + [self.pathLookup hash];
  case DBFILESDeleteErrorPathWrite:
    result = prime * result + [self.pathWrite hash];
  case DBFILESDeleteErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteError:other];
}

- (BOOL)isEqualToDeleteError:(DBFILESDeleteError *)aDeleteError {
  if (self == aDeleteError) {
    return YES;
  }
  if (self.tag != aDeleteError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESDeleteErrorPathLookup:
    return [self.pathLookup isEqual:aDeleteError.pathLookup];
  case DBFILESDeleteErrorPathWrite:
    return [self.pathWrite isEqual:aDeleteError.pathWrite];
  case DBFILESDeleteErrorOther:
    return [[self tagName] isEqual:[aDeleteError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteErrorSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPathLookup]) {
    jsonDict[@"path_lookup"] = [[DBFILESLookupErrorSerializer serialize:valueObj.pathLookup] mutableCopy];
    jsonDict[@".tag"] = @"path_lookup";
  } else if ([valueObj isPathWrite]) {
    jsonDict[@"path_write"] = [[DBFILESWriteErrorSerializer serialize:valueObj.pathWrite] mutableCopy];
    jsonDict[@".tag"] = @"path_write";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESDeleteError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path_lookup"]) {
    DBFILESLookupError *pathLookup = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path_lookup"]];
    return [[DBFILESDeleteError alloc] initWithPathLookup:pathLookup];
  } else if ([tag isEqualToString:@"path_write"]) {
    DBFILESWriteError *pathWrite = [DBFILESWriteErrorSerializer deserialize:valueDict[@"path_write"]];
    return [[DBFILESDeleteError alloc] initWithPathWrite:pathWrite];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESDeleteError alloc] initWithOther];
  } else {
    return [[DBFILESDeleteError alloc] initWithOther];
  }
}

@end

#import "DBFILESDeleteResult.h"
#import "DBFILESMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeleteResult

#pragma mark - Constructors

- (instancetype)initWithMetadata:(DBFILESMetadata *)metadata {

  self = [super init];
  if (self) {
    _metadata = metadata;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeleteResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeleteResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeleteResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.metadata hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeleteResult:other];
}

- (BOOL)isEqualToDeleteResult:(DBFILESDeleteResult *)aDeleteResult {
  if (self == aDeleteResult) {
    return YES;
  }
  if (![self.metadata isEqual:aDeleteResult.metadata]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeleteResultSerializer

+ (NSDictionary *)serialize:(DBFILESDeleteResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"metadata"] = [DBFILESMetadataSerializer serialize:valueObj.metadata];

  return jsonDict;
}

+ (DBFILESDeleteResult *)deserialize:(NSDictionary *)valueDict {
  DBFILESMetadata *metadata = [DBFILESMetadataSerializer deserialize:valueDict[@"metadata"]];

  return [[DBFILESDeleteResult alloc] initWithMetadata:metadata];
}

@end

#import "DBFILESDeletedMetadata.h"
#import "DBFILESFileMetadata.h"
#import "DBFILESFolderMetadata.h"
#import "DBFILESMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESMetadata

#pragma mark - Constructors

- (instancetype)initWithName:(NSString *)name
                   pathLower:(NSString *)pathLower
                 pathDisplay:(NSString *)pathDisplay
        parentSharedFolderId:(NSString *)parentSharedFolderId {
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](
      parentSharedFolderId);

  self = [super init];
  if (self) {
    _name = name;
    _pathLower = pathLower;
    _pathDisplay = pathDisplay;
    _parentSharedFolderId = parentSharedFolderId;
  }
  return self;
}

- (instancetype)initWithName:(NSString *)name {
  return [self initWithName:name pathLower:nil pathDisplay:nil parentSharedFolderId:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.name hash];
  if (self.pathLower) {
    result = prime * result + [self.pathLower hash];
  }
  if (self.pathDisplay) {
    result = prime * result + [self.pathDisplay hash];
  }
  if (self.parentSharedFolderId) {
    result = prime * result + [self.parentSharedFolderId hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToMetadata:other];
}

- (BOOL)isEqualToMetadata:(DBFILESMetadata *)aMetadata {
  if (self == aMetadata) {
    return YES;
  }
  if (![self.name isEqual:aMetadata.name]) {
    return NO;
  }
  if (self.pathLower) {
    if (![self.pathLower isEqual:aMetadata.pathLower]) {
      return NO;
    }
  }
  if (self.pathDisplay) {
    if (![self.pathDisplay isEqual:aMetadata.pathDisplay]) {
      return NO;
    }
  }
  if (self.parentSharedFolderId) {
    if (![self.parentSharedFolderId isEqual:aMetadata.parentSharedFolderId]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"name"] = valueObj.name;
  if (valueObj.pathLower) {
    jsonDict[@"path_lower"] = valueObj.pathLower;
  }
  if (valueObj.pathDisplay) {
    jsonDict[@"path_display"] = valueObj.pathDisplay;
  }
  if (valueObj.parentSharedFolderId) {
    jsonDict[@"parent_shared_folder_id"] = valueObj.parentSharedFolderId;
  }

  if ([valueObj isKindOfClass:[DBFILESFileMetadata class]]) {
    NSDictionary *subTypeFields = [DBFILESFileMetadataSerializer serialize:(DBFILESFileMetadata *)valueObj];
    for (NSString *key in subTypeFields) {
      jsonDict[key] = subTypeFields[key];
    }
    jsonDict[@".tag"] = @"file";
  } else if ([valueObj isKindOfClass:[DBFILESFolderMetadata class]]) {
    NSDictionary *subTypeFields = [DBFILESFolderMetadataSerializer serialize:(DBFILESFolderMetadata *)valueObj];
    for (NSString *key in subTypeFields) {
      jsonDict[key] = subTypeFields[key];
    }
    jsonDict[@".tag"] = @"folder";
  } else if ([valueObj isKindOfClass:[DBFILESDeletedMetadata class]]) {
    NSDictionary *subTypeFields = [DBFILESDeletedMetadataSerializer serialize:(DBFILESDeletedMetadata *)valueObj];
    for (NSString *key in subTypeFields) {
      jsonDict[key] = subTypeFields[key];
    }
    jsonDict[@".tag"] = @"deleted";
  }

  return jsonDict;
}

+ (DBFILESMetadata *)deserialize:(NSDictionary *)valueDict {
  if ([valueDict[@".tag"] isEqualToString:@"file"]) {
    return [DBFILESFileMetadataSerializer deserialize:valueDict];
  }
  if ([valueDict[@".tag"] isEqualToString:@"folder"]) {
    return [DBFILESFolderMetadataSerializer deserialize:valueDict];
  }
  if ([valueDict[@".tag"] isEqualToString:@"deleted"]) {
    return [DBFILESDeletedMetadataSerializer deserialize:valueDict];
  }

  @throw([NSException
      exceptionWithName:@"InvalidTag"
                 reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
               userInfo:nil]);
}

@end

#import "DBFILESDeletedMetadata.h"
#import "DBFILESMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDeletedMetadata

#pragma mark - Constructors

- (instancetype)initWithName:(NSString *)name
                   pathLower:(NSString *)pathLower
                 pathDisplay:(NSString *)pathDisplay
        parentSharedFolderId:(NSString *)parentSharedFolderId {
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](
      parentSharedFolderId);

  self =
      [super initWithName:name pathLower:pathLower pathDisplay:pathDisplay parentSharedFolderId:parentSharedFolderId];
  if (self) {
  }
  return self;
}

- (instancetype)initWithName:(NSString *)name {
  return [self initWithName:name pathLower:nil pathDisplay:nil parentSharedFolderId:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDeletedMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDeletedMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDeletedMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.name hash];
  if (self.pathLower) {
    result = prime * result + [self.pathLower hash];
  }
  if (self.pathDisplay) {
    result = prime * result + [self.pathDisplay hash];
  }
  if (self.parentSharedFolderId) {
    result = prime * result + [self.parentSharedFolderId hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDeletedMetadata:other];
}

- (BOOL)isEqualToDeletedMetadata:(DBFILESDeletedMetadata *)aDeletedMetadata {
  if (self == aDeletedMetadata) {
    return YES;
  }
  if (![self.name isEqual:aDeletedMetadata.name]) {
    return NO;
  }
  if (self.pathLower) {
    if (![self.pathLower isEqual:aDeletedMetadata.pathLower]) {
      return NO;
    }
  }
  if (self.pathDisplay) {
    if (![self.pathDisplay isEqual:aDeletedMetadata.pathDisplay]) {
      return NO;
    }
  }
  if (self.parentSharedFolderId) {
    if (![self.parentSharedFolderId isEqual:aDeletedMetadata.parentSharedFolderId]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDeletedMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESDeletedMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"name"] = valueObj.name;
  if (valueObj.pathLower) {
    jsonDict[@"path_lower"] = valueObj.pathLower;
  }
  if (valueObj.pathDisplay) {
    jsonDict[@"path_display"] = valueObj.pathDisplay;
  }
  if (valueObj.parentSharedFolderId) {
    jsonDict[@"parent_shared_folder_id"] = valueObj.parentSharedFolderId;
  }

  return jsonDict;
}

+ (DBFILESDeletedMetadata *)deserialize:(NSDictionary *)valueDict {
  NSString *name = valueDict[@"name"];
  NSString *pathLower = valueDict[@"path_lower"] ?: nil;
  NSString *pathDisplay = valueDict[@"path_display"] ?: nil;
  NSString *parentSharedFolderId = valueDict[@"parent_shared_folder_id"] ?: nil;

  return [[DBFILESDeletedMetadata alloc] initWithName:name
                                            pathLower:pathLower
                                          pathDisplay:pathDisplay
                                 parentSharedFolderId:parentSharedFolderId];
}

@end

#import "DBFILESDimensions.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDimensions

#pragma mark - Constructors

- (instancetype)initWithHeight:(NSNumber *)height width:(NSNumber *)width {

  self = [super init];
  if (self) {
    _height = height;
    _width = width;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDimensionsSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDimensionsSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDimensionsSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.height hash];
  result = prime * result + [self.width hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDimensions:other];
}

- (BOOL)isEqualToDimensions:(DBFILESDimensions *)aDimensions {
  if (self == aDimensions) {
    return YES;
  }
  if (![self.height isEqual:aDimensions.height]) {
    return NO;
  }
  if (![self.width isEqual:aDimensions.width]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDimensionsSerializer

+ (NSDictionary *)serialize:(DBFILESDimensions *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"height"] = valueObj.height;
  jsonDict[@"width"] = valueObj.width;

  return jsonDict;
}

+ (DBFILESDimensions *)deserialize:(NSDictionary *)valueDict {
  NSNumber *height = valueDict[@"height"];
  NSNumber *width = valueDict[@"width"];

  return [[DBFILESDimensions alloc] initWithHeight:height width:width];
}

@end

#import "DBFILESDownloadArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDownloadArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path rev:(NSString *)rev {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:@(9) maxLength:nil pattern:@"[0-9a-f]+"]](rev);

  self = [super init];
  if (self) {
    _path = path;
    _rev = rev;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path rev:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDownloadArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDownloadArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDownloadArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  if (self.rev) {
    result = prime * result + [self.rev hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDownloadArg:other];
}

- (BOOL)isEqualToDownloadArg:(DBFILESDownloadArg *)aDownloadArg {
  if (self == aDownloadArg) {
    return YES;
  }
  if (![self.path isEqual:aDownloadArg.path]) {
    return NO;
  }
  if (self.rev) {
    if (![self.rev isEqual:aDownloadArg.rev]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDownloadArgSerializer

+ (NSDictionary *)serialize:(DBFILESDownloadArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  if (valueObj.rev) {
    jsonDict[@"rev"] = valueObj.rev;
  }

  return jsonDict;
}

+ (DBFILESDownloadArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSString *rev = valueDict[@"rev"] ?: nil;

  return [[DBFILESDownloadArg alloc] initWithPath:path rev:rev];
}

@end

#import "DBFILESDownloadError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESDownloadError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESDownloadErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESDownloadErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESDownloadErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESDownloadErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESDownloadErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESDownloadErrorPath:
    return @"DBFILESDownloadErrorPath";
  case DBFILESDownloadErrorOther:
    return @"DBFILESDownloadErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESDownloadErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESDownloadErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESDownloadErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESDownloadErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESDownloadErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToDownloadError:other];
}

- (BOOL)isEqualToDownloadError:(DBFILESDownloadError *)aDownloadError {
  if (self == aDownloadError) {
    return YES;
  }
  if (self.tag != aDownloadError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESDownloadErrorPath:
    return [self.path isEqual:aDownloadError.path];
  case DBFILESDownloadErrorOther:
    return [[self tagName] isEqual:[aDownloadError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESDownloadErrorSerializer

+ (NSDictionary *)serialize:(DBFILESDownloadError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESDownloadError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESDownloadError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESDownloadError alloc] initWithOther];
  } else {
    return [[DBFILESDownloadError alloc] initWithOther];
  }
}

@end

#import "DBFILESFileMetadata.h"
#import "DBFILESFileSharingInfo.h"
#import "DBFILESMediaInfo.h"
#import "DBFILESMetadata.h"
#import "DBPROPERTIESPropertyGroup.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESFileMetadata

#pragma mark - Constructors

- (instancetype)initWithName:(NSString *)name
                         id_:(NSString *)id_
              clientModified:(NSDate *)clientModified
              serverModified:(NSDate *)serverModified
                         rev:(NSString *)rev
                        size:(NSNumber *)size
                   pathLower:(NSString *)pathLower
                 pathDisplay:(NSString *)pathDisplay
        parentSharedFolderId:(NSString *)parentSharedFolderId
                   mediaInfo:(DBFILESMediaInfo *)mediaInfo
                 sharingInfo:(DBFILESFileSharingInfo *)sharingInfo
              propertyGroups:(NSArray<DBPROPERTIESPropertyGroup *> *)propertyGroups
    hasExplicitSharedMembers:(NSNumber *)hasExplicitSharedMembers
                 contentHash:(NSString *)contentHash {
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:nil](id_);
  [DBStoneValidators stringValidator:@(9) maxLength:nil pattern:@"[0-9a-f]+"](rev);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](
      parentSharedFolderId);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil]](propertyGroups);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:@(64) maxLength:@(64) pattern:nil]](contentHash);

  self =
      [super initWithName:name pathLower:pathLower pathDisplay:pathDisplay parentSharedFolderId:parentSharedFolderId];
  if (self) {
    _id_ = id_;
    _clientModified = clientModified;
    _serverModified = serverModified;
    _rev = rev;
    _size = size;
    _mediaInfo = mediaInfo;
    _sharingInfo = sharingInfo;
    _propertyGroups = propertyGroups;
    _hasExplicitSharedMembers = hasExplicitSharedMembers;
    _contentHash = contentHash;
  }
  return self;
}

- (instancetype)initWithName:(NSString *)name
                         id_:(NSString *)id_
              clientModified:(NSDate *)clientModified
              serverModified:(NSDate *)serverModified
                         rev:(NSString *)rev
                        size:(NSNumber *)size {
  return [self initWithName:name
                           id_:id_
                clientModified:clientModified
                serverModified:serverModified
                           rev:rev
                          size:size
                     pathLower:nil
                   pathDisplay:nil
          parentSharedFolderId:nil
                     mediaInfo:nil
                   sharingInfo:nil
                propertyGroups:nil
      hasExplicitSharedMembers:nil
                   contentHash:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESFileMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESFileMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESFileMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.name hash];
  result = prime * result + [self.id_ hash];
  result = prime * result + [self.clientModified hash];
  result = prime * result + [self.serverModified hash];
  result = prime * result + [self.rev hash];
  result = prime * result + [self.size hash];
  if (self.pathLower) {
    result = prime * result + [self.pathLower hash];
  }
  if (self.pathDisplay) {
    result = prime * result + [self.pathDisplay hash];
  }
  if (self.parentSharedFolderId) {
    result = prime * result + [self.parentSharedFolderId hash];
  }
  if (self.mediaInfo) {
    result = prime * result + [self.mediaInfo hash];
  }
  if (self.sharingInfo) {
    result = prime * result + [self.sharingInfo hash];
  }
  if (self.propertyGroups) {
    result = prime * result + [self.propertyGroups hash];
  }
  if (self.hasExplicitSharedMembers) {
    result = prime * result + [self.hasExplicitSharedMembers hash];
  }
  if (self.contentHash) {
    result = prime * result + [self.contentHash hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToFileMetadata:other];
}

- (BOOL)isEqualToFileMetadata:(DBFILESFileMetadata *)aFileMetadata {
  if (self == aFileMetadata) {
    return YES;
  }
  if (![self.name isEqual:aFileMetadata.name]) {
    return NO;
  }
  if (![self.id_ isEqual:aFileMetadata.id_]) {
    return NO;
  }
  if (![self.clientModified isEqual:aFileMetadata.clientModified]) {
    return NO;
  }
  if (![self.serverModified isEqual:aFileMetadata.serverModified]) {
    return NO;
  }
  if (![self.rev isEqual:aFileMetadata.rev]) {
    return NO;
  }
  if (![self.size isEqual:aFileMetadata.size]) {
    return NO;
  }
  if (self.pathLower) {
    if (![self.pathLower isEqual:aFileMetadata.pathLower]) {
      return NO;
    }
  }
  if (self.pathDisplay) {
    if (![self.pathDisplay isEqual:aFileMetadata.pathDisplay]) {
      return NO;
    }
  }
  if (self.parentSharedFolderId) {
    if (![self.parentSharedFolderId isEqual:aFileMetadata.parentSharedFolderId]) {
      return NO;
    }
  }
  if (self.mediaInfo) {
    if (![self.mediaInfo isEqual:aFileMetadata.mediaInfo]) {
      return NO;
    }
  }
  if (self.sharingInfo) {
    if (![self.sharingInfo isEqual:aFileMetadata.sharingInfo]) {
      return NO;
    }
  }
  if (self.propertyGroups) {
    if (![self.propertyGroups isEqual:aFileMetadata.propertyGroups]) {
      return NO;
    }
  }
  if (self.hasExplicitSharedMembers) {
    if (![self.hasExplicitSharedMembers isEqual:aFileMetadata.hasExplicitSharedMembers]) {
      return NO;
    }
  }
  if (self.contentHash) {
    if (![self.contentHash isEqual:aFileMetadata.contentHash]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESFileMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESFileMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"name"] = valueObj.name;
  jsonDict[@"id"] = valueObj.id_;
  jsonDict[@"client_modified"] =
      [DBNSDateSerializer serialize:valueObj.clientModified dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  jsonDict[@"server_modified"] =
      [DBNSDateSerializer serialize:valueObj.serverModified dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  jsonDict[@"rev"] = valueObj.rev;
  jsonDict[@"size"] = valueObj.size;
  if (valueObj.pathLower) {
    jsonDict[@"path_lower"] = valueObj.pathLower;
  }
  if (valueObj.pathDisplay) {
    jsonDict[@"path_display"] = valueObj.pathDisplay;
  }
  if (valueObj.parentSharedFolderId) {
    jsonDict[@"parent_shared_folder_id"] = valueObj.parentSharedFolderId;
  }
  if (valueObj.mediaInfo) {
    jsonDict[@"media_info"] = [DBFILESMediaInfoSerializer serialize:valueObj.mediaInfo];
  }
  if (valueObj.sharingInfo) {
    jsonDict[@"sharing_info"] = [DBFILESFileSharingInfoSerializer serialize:valueObj.sharingInfo];
  }
  if (valueObj.propertyGroups) {
    jsonDict[@"property_groups"] = [DBArraySerializer serialize:valueObj.propertyGroups
                                                      withBlock:^id(id elem0) {
                                                        return [DBPROPERTIESPropertyGroupSerializer serialize:elem0];
                                                      }];
  }
  if (valueObj.hasExplicitSharedMembers) {
    jsonDict[@"has_explicit_shared_members"] = valueObj.hasExplicitSharedMembers;
  }
  if (valueObj.contentHash) {
    jsonDict[@"content_hash"] = valueObj.contentHash;
  }

  return jsonDict;
}

+ (DBFILESFileMetadata *)deserialize:(NSDictionary *)valueDict {
  NSString *name = valueDict[@"name"];
  NSString *id_ = valueDict[@"id"];
  NSDate *clientModified =
      [DBNSDateSerializer deserialize:valueDict[@"client_modified"] dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  NSDate *serverModified =
      [DBNSDateSerializer deserialize:valueDict[@"server_modified"] dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  NSString *rev = valueDict[@"rev"];
  NSNumber *size = valueDict[@"size"];
  NSString *pathLower = valueDict[@"path_lower"] ?: nil;
  NSString *pathDisplay = valueDict[@"path_display"] ?: nil;
  NSString *parentSharedFolderId = valueDict[@"parent_shared_folder_id"] ?: nil;
  DBFILESMediaInfo *mediaInfo =
      valueDict[@"media_info"] ? [DBFILESMediaInfoSerializer deserialize:valueDict[@"media_info"]] : nil;
  DBFILESFileSharingInfo *sharingInfo =
      valueDict[@"sharing_info"] ? [DBFILESFileSharingInfoSerializer deserialize:valueDict[@"sharing_info"]] : nil;
  NSArray<DBPROPERTIESPropertyGroup *> *propertyGroups =
      valueDict[@"property_groups"]
          ? [DBArraySerializer deserialize:valueDict[@"property_groups"]
                                 withBlock:^id(id elem0) {
                                   return [DBPROPERTIESPropertyGroupSerializer deserialize:elem0];
                                 }]
          : nil;
  NSNumber *hasExplicitSharedMembers = valueDict[@"has_explicit_shared_members"] ?: nil;
  NSString *contentHash = valueDict[@"content_hash"] ?: nil;

  return [[DBFILESFileMetadata alloc] initWithName:name
                                               id_:id_
                                    clientModified:clientModified
                                    serverModified:serverModified
                                               rev:rev
                                              size:size
                                         pathLower:pathLower
                                       pathDisplay:pathDisplay
                              parentSharedFolderId:parentSharedFolderId
                                         mediaInfo:mediaInfo
                                       sharingInfo:sharingInfo
                                    propertyGroups:propertyGroups
                          hasExplicitSharedMembers:hasExplicitSharedMembers
                                       contentHash:contentHash];
}

@end

#import "DBFILESSharingInfo.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSharingInfo

#pragma mark - Constructors

- (instancetype)initWithReadOnly:(NSNumber *)readOnly {

  self = [super init];
  if (self) {
    _readOnly = readOnly;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSharingInfoSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSharingInfoSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSharingInfoSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.readOnly hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSharingInfo:other];
}

- (BOOL)isEqualToSharingInfo:(DBFILESSharingInfo *)aSharingInfo {
  if (self == aSharingInfo) {
    return YES;
  }
  if (![self.readOnly isEqual:aSharingInfo.readOnly]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSharingInfoSerializer

+ (NSDictionary *)serialize:(DBFILESSharingInfo *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"read_only"] = valueObj.readOnly;

  return jsonDict;
}

+ (DBFILESSharingInfo *)deserialize:(NSDictionary *)valueDict {
  NSNumber *readOnly = valueDict[@"read_only"];

  return [[DBFILESSharingInfo alloc] initWithReadOnly:readOnly];
}

@end

#import "DBFILESFileSharingInfo.h"
#import "DBFILESSharingInfo.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESFileSharingInfo

#pragma mark - Constructors

- (instancetype)initWithReadOnly:(NSNumber *)readOnly
            parentSharedFolderId:(NSString *)parentSharedFolderId
                      modifiedBy:(NSString *)modifiedBy {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"](parentSharedFolderId);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:@(40) maxLength:@(40) pattern:nil]](modifiedBy);

  self = [super initWithReadOnly:readOnly];
  if (self) {
    _parentSharedFolderId = parentSharedFolderId;
    _modifiedBy = modifiedBy;
  }
  return self;
}

- (instancetype)initWithReadOnly:(NSNumber *)readOnly parentSharedFolderId:(NSString *)parentSharedFolderId {
  return [self initWithReadOnly:readOnly parentSharedFolderId:parentSharedFolderId modifiedBy:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESFileSharingInfoSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESFileSharingInfoSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESFileSharingInfoSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.readOnly hash];
  result = prime * result + [self.parentSharedFolderId hash];
  if (self.modifiedBy) {
    result = prime * result + [self.modifiedBy hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToFileSharingInfo:other];
}

- (BOOL)isEqualToFileSharingInfo:(DBFILESFileSharingInfo *)aFileSharingInfo {
  if (self == aFileSharingInfo) {
    return YES;
  }
  if (![self.readOnly isEqual:aFileSharingInfo.readOnly]) {
    return NO;
  }
  if (![self.parentSharedFolderId isEqual:aFileSharingInfo.parentSharedFolderId]) {
    return NO;
  }
  if (self.modifiedBy) {
    if (![self.modifiedBy isEqual:aFileSharingInfo.modifiedBy]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESFileSharingInfoSerializer

+ (NSDictionary *)serialize:(DBFILESFileSharingInfo *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"read_only"] = valueObj.readOnly;
  jsonDict[@"parent_shared_folder_id"] = valueObj.parentSharedFolderId;
  if (valueObj.modifiedBy) {
    jsonDict[@"modified_by"] = valueObj.modifiedBy;
  }

  return jsonDict;
}

+ (DBFILESFileSharingInfo *)deserialize:(NSDictionary *)valueDict {
  NSNumber *readOnly = valueDict[@"read_only"];
  NSString *parentSharedFolderId = valueDict[@"parent_shared_folder_id"];
  NSString *modifiedBy = valueDict[@"modified_by"] ?: nil;

  return [[DBFILESFileSharingInfo alloc] initWithReadOnly:readOnly
                                     parentSharedFolderId:parentSharedFolderId
                                               modifiedBy:modifiedBy];
}

@end

#import "DBFILESFolderMetadata.h"
#import "DBFILESFolderSharingInfo.h"
#import "DBFILESMetadata.h"
#import "DBPROPERTIESPropertyGroup.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESFolderMetadata

#pragma mark - Constructors

- (instancetype)initWithName:(NSString *)name
                         id_:(NSString *)id_
                   pathLower:(NSString *)pathLower
                 pathDisplay:(NSString *)pathDisplay
        parentSharedFolderId:(NSString *)parentSharedFolderId
              sharedFolderId:(NSString *)sharedFolderId
                 sharingInfo:(DBFILESFolderSharingInfo *)sharingInfo
              propertyGroups:(NSArray<DBPROPERTIESPropertyGroup *> *)propertyGroups {
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:nil](id_);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](
      parentSharedFolderId);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](sharedFolderId);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil]](propertyGroups);

  self =
      [super initWithName:name pathLower:pathLower pathDisplay:pathDisplay parentSharedFolderId:parentSharedFolderId];
  if (self) {
    _id_ = id_;
    _sharedFolderId = sharedFolderId;
    _sharingInfo = sharingInfo;
    _propertyGroups = propertyGroups;
  }
  return self;
}

- (instancetype)initWithName:(NSString *)name id_:(NSString *)id_ {
  return [self initWithName:name
                        id_:id_
                  pathLower:nil
                pathDisplay:nil
       parentSharedFolderId:nil
             sharedFolderId:nil
                sharingInfo:nil
             propertyGroups:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESFolderMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESFolderMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESFolderMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.name hash];
  result = prime * result + [self.id_ hash];
  if (self.pathLower) {
    result = prime * result + [self.pathLower hash];
  }
  if (self.pathDisplay) {
    result = prime * result + [self.pathDisplay hash];
  }
  if (self.parentSharedFolderId) {
    result = prime * result + [self.parentSharedFolderId hash];
  }
  if (self.sharedFolderId) {
    result = prime * result + [self.sharedFolderId hash];
  }
  if (self.sharingInfo) {
    result = prime * result + [self.sharingInfo hash];
  }
  if (self.propertyGroups) {
    result = prime * result + [self.propertyGroups hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToFolderMetadata:other];
}

- (BOOL)isEqualToFolderMetadata:(DBFILESFolderMetadata *)aFolderMetadata {
  if (self == aFolderMetadata) {
    return YES;
  }
  if (![self.name isEqual:aFolderMetadata.name]) {
    return NO;
  }
  if (![self.id_ isEqual:aFolderMetadata.id_]) {
    return NO;
  }
  if (self.pathLower) {
    if (![self.pathLower isEqual:aFolderMetadata.pathLower]) {
      return NO;
    }
  }
  if (self.pathDisplay) {
    if (![self.pathDisplay isEqual:aFolderMetadata.pathDisplay]) {
      return NO;
    }
  }
  if (self.parentSharedFolderId) {
    if (![self.parentSharedFolderId isEqual:aFolderMetadata.parentSharedFolderId]) {
      return NO;
    }
  }
  if (self.sharedFolderId) {
    if (![self.sharedFolderId isEqual:aFolderMetadata.sharedFolderId]) {
      return NO;
    }
  }
  if (self.sharingInfo) {
    if (![self.sharingInfo isEqual:aFolderMetadata.sharingInfo]) {
      return NO;
    }
  }
  if (self.propertyGroups) {
    if (![self.propertyGroups isEqual:aFolderMetadata.propertyGroups]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESFolderMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESFolderMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"name"] = valueObj.name;
  jsonDict[@"id"] = valueObj.id_;
  if (valueObj.pathLower) {
    jsonDict[@"path_lower"] = valueObj.pathLower;
  }
  if (valueObj.pathDisplay) {
    jsonDict[@"path_display"] = valueObj.pathDisplay;
  }
  if (valueObj.parentSharedFolderId) {
    jsonDict[@"parent_shared_folder_id"] = valueObj.parentSharedFolderId;
  }
  if (valueObj.sharedFolderId) {
    jsonDict[@"shared_folder_id"] = valueObj.sharedFolderId;
  }
  if (valueObj.sharingInfo) {
    jsonDict[@"sharing_info"] = [DBFILESFolderSharingInfoSerializer serialize:valueObj.sharingInfo];
  }
  if (valueObj.propertyGroups) {
    jsonDict[@"property_groups"] = [DBArraySerializer serialize:valueObj.propertyGroups
                                                      withBlock:^id(id elem0) {
                                                        return [DBPROPERTIESPropertyGroupSerializer serialize:elem0];
                                                      }];
  }

  return jsonDict;
}

+ (DBFILESFolderMetadata *)deserialize:(NSDictionary *)valueDict {
  NSString *name = valueDict[@"name"];
  NSString *id_ = valueDict[@"id"];
  NSString *pathLower = valueDict[@"path_lower"] ?: nil;
  NSString *pathDisplay = valueDict[@"path_display"] ?: nil;
  NSString *parentSharedFolderId = valueDict[@"parent_shared_folder_id"] ?: nil;
  NSString *sharedFolderId = valueDict[@"shared_folder_id"] ?: nil;
  DBFILESFolderSharingInfo *sharingInfo =
      valueDict[@"sharing_info"] ? [DBFILESFolderSharingInfoSerializer deserialize:valueDict[@"sharing_info"]] : nil;
  NSArray<DBPROPERTIESPropertyGroup *> *propertyGroups =
      valueDict[@"property_groups"]
          ? [DBArraySerializer deserialize:valueDict[@"property_groups"]
                                 withBlock:^id(id elem0) {
                                   return [DBPROPERTIESPropertyGroupSerializer deserialize:elem0];
                                 }]
          : nil;

  return [[DBFILESFolderMetadata alloc] initWithName:name
                                                 id_:id_
                                           pathLower:pathLower
                                         pathDisplay:pathDisplay
                                parentSharedFolderId:parentSharedFolderId
                                      sharedFolderId:sharedFolderId
                                         sharingInfo:sharingInfo
                                      propertyGroups:propertyGroups];
}

@end

#import "DBFILESFolderSharingInfo.h"
#import "DBFILESSharingInfo.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESFolderSharingInfo

#pragma mark - Constructors

- (instancetype)initWithReadOnly:(NSNumber *)readOnly
            parentSharedFolderId:(NSString *)parentSharedFolderId
                  sharedFolderId:(NSString *)sharedFolderId
                    traverseOnly:(NSNumber *)traverseOnly
                        noAccess:(NSNumber *)noAccess {
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](
      parentSharedFolderId);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:nil maxLength:nil pattern:@"[-_0-9a-zA-Z:]+"]](sharedFolderId);

  self = [super initWithReadOnly:readOnly];
  if (self) {
    _parentSharedFolderId = parentSharedFolderId;
    _sharedFolderId = sharedFolderId;
    _traverseOnly = traverseOnly ?: @NO;
    _noAccess = noAccess ?: @NO;
  }
  return self;
}

- (instancetype)initWithReadOnly:(NSNumber *)readOnly {
  return [self initWithReadOnly:readOnly parentSharedFolderId:nil sharedFolderId:nil traverseOnly:nil noAccess:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESFolderSharingInfoSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESFolderSharingInfoSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESFolderSharingInfoSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.readOnly hash];
  if (self.parentSharedFolderId) {
    result = prime * result + [self.parentSharedFolderId hash];
  }
  if (self.sharedFolderId) {
    result = prime * result + [self.sharedFolderId hash];
  }
  result = prime * result + [self.traverseOnly hash];
  result = prime * result + [self.noAccess hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToFolderSharingInfo:other];
}

- (BOOL)isEqualToFolderSharingInfo:(DBFILESFolderSharingInfo *)aFolderSharingInfo {
  if (self == aFolderSharingInfo) {
    return YES;
  }
  if (![self.readOnly isEqual:aFolderSharingInfo.readOnly]) {
    return NO;
  }
  if (self.parentSharedFolderId) {
    if (![self.parentSharedFolderId isEqual:aFolderSharingInfo.parentSharedFolderId]) {
      return NO;
    }
  }
  if (self.sharedFolderId) {
    if (![self.sharedFolderId isEqual:aFolderSharingInfo.sharedFolderId]) {
      return NO;
    }
  }
  if (![self.traverseOnly isEqual:aFolderSharingInfo.traverseOnly]) {
    return NO;
  }
  if (![self.noAccess isEqual:aFolderSharingInfo.noAccess]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESFolderSharingInfoSerializer

+ (NSDictionary *)serialize:(DBFILESFolderSharingInfo *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"read_only"] = valueObj.readOnly;
  if (valueObj.parentSharedFolderId) {
    jsonDict[@"parent_shared_folder_id"] = valueObj.parentSharedFolderId;
  }
  if (valueObj.sharedFolderId) {
    jsonDict[@"shared_folder_id"] = valueObj.sharedFolderId;
  }
  jsonDict[@"traverse_only"] = valueObj.traverseOnly;
  jsonDict[@"no_access"] = valueObj.noAccess;

  return jsonDict;
}

+ (DBFILESFolderSharingInfo *)deserialize:(NSDictionary *)valueDict {
  NSNumber *readOnly = valueDict[@"read_only"];
  NSString *parentSharedFolderId = valueDict[@"parent_shared_folder_id"] ?: nil;
  NSString *sharedFolderId = valueDict[@"shared_folder_id"] ?: nil;
  NSNumber *traverseOnly = valueDict[@"traverse_only"] ?: @NO;
  NSNumber *noAccess = valueDict[@"no_access"] ?: @NO;

  return [[DBFILESFolderSharingInfo alloc] initWithReadOnly:readOnly
                                       parentSharedFolderId:parentSharedFolderId
                                             sharedFolderId:sharedFolderId
                                               traverseOnly:traverseOnly
                                                   noAccess:noAccess];
}

@end

#import "DBFILESGetCopyReferenceArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetCopyReferenceArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetCopyReferenceArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetCopyReferenceArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetCopyReferenceArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetCopyReferenceArg:other];
}

- (BOOL)isEqualToGetCopyReferenceArg:(DBFILESGetCopyReferenceArg *)aGetCopyReferenceArg {
  if (self == aGetCopyReferenceArg) {
    return YES;
  }
  if (![self.path isEqual:aGetCopyReferenceArg.path]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetCopyReferenceArgSerializer

+ (NSDictionary *)serialize:(DBFILESGetCopyReferenceArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;

  return jsonDict;
}

+ (DBFILESGetCopyReferenceArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];

  return [[DBFILESGetCopyReferenceArg alloc] initWithPath:path];
}

@end

#import "DBFILESGetCopyReferenceError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetCopyReferenceError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESGetCopyReferenceErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESGetCopyReferenceErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESGetCopyReferenceErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESGetCopyReferenceErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESGetCopyReferenceErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESGetCopyReferenceErrorPath:
    return @"DBFILESGetCopyReferenceErrorPath";
  case DBFILESGetCopyReferenceErrorOther:
    return @"DBFILESGetCopyReferenceErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetCopyReferenceErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetCopyReferenceErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetCopyReferenceErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESGetCopyReferenceErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESGetCopyReferenceErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetCopyReferenceError:other];
}

- (BOOL)isEqualToGetCopyReferenceError:(DBFILESGetCopyReferenceError *)aGetCopyReferenceError {
  if (self == aGetCopyReferenceError) {
    return YES;
  }
  if (self.tag != aGetCopyReferenceError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESGetCopyReferenceErrorPath:
    return [self.path isEqual:aGetCopyReferenceError.path];
  case DBFILESGetCopyReferenceErrorOther:
    return [[self tagName] isEqual:[aGetCopyReferenceError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetCopyReferenceErrorSerializer

+ (NSDictionary *)serialize:(DBFILESGetCopyReferenceError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESGetCopyReferenceError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESGetCopyReferenceError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESGetCopyReferenceError alloc] initWithOther];
  } else {
    return [[DBFILESGetCopyReferenceError alloc] initWithOther];
  }
}

@end

#import "DBFILESGetCopyReferenceResult.h"
#import "DBFILESMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetCopyReferenceResult

#pragma mark - Constructors

- (instancetype)initWithMetadata:(DBFILESMetadata *)metadata
                  dCopyReference:(NSString *)dCopyReference
                         expires:(NSDate *)expires {

  self = [super init];
  if (self) {
    _metadata = metadata;
    _dCopyReference = dCopyReference;
    _expires = expires;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetCopyReferenceResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetCopyReferenceResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetCopyReferenceResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.metadata hash];
  result = prime * result + [self.dCopyReference hash];
  result = prime * result + [self.expires hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetCopyReferenceResult:other];
}

- (BOOL)isEqualToGetCopyReferenceResult:(DBFILESGetCopyReferenceResult *)aGetCopyReferenceResult {
  if (self == aGetCopyReferenceResult) {
    return YES;
  }
  if (![self.metadata isEqual:aGetCopyReferenceResult.metadata]) {
    return NO;
  }
  if (![self.dCopyReference isEqual:aGetCopyReferenceResult.dCopyReference]) {
    return NO;
  }
  if (![self.expires isEqual:aGetCopyReferenceResult.expires]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetCopyReferenceResultSerializer

+ (NSDictionary *)serialize:(DBFILESGetCopyReferenceResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"metadata"] = [DBFILESMetadataSerializer serialize:valueObj.metadata];
  jsonDict[@"copy_reference"] = valueObj.dCopyReference;
  jsonDict[@"expires"] = [DBNSDateSerializer serialize:valueObj.expires dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];

  return jsonDict;
}

+ (DBFILESGetCopyReferenceResult *)deserialize:(NSDictionary *)valueDict {
  DBFILESMetadata *metadata = [DBFILESMetadataSerializer deserialize:valueDict[@"metadata"]];
  NSString *dCopyReference = valueDict[@"copy_reference"];
  NSDate *expires = [DBNSDateSerializer deserialize:valueDict[@"expires"] dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];

  return
      [[DBFILESGetCopyReferenceResult alloc] initWithMetadata:metadata dCopyReference:dCopyReference expires:expires];
}

@end

#import "DBFILESGetTemporaryLinkArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetTemporaryLinkArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetTemporaryLinkArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetTemporaryLinkArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetTemporaryLinkArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetTemporaryLinkArg:other];
}

- (BOOL)isEqualToGetTemporaryLinkArg:(DBFILESGetTemporaryLinkArg *)aGetTemporaryLinkArg {
  if (self == aGetTemporaryLinkArg) {
    return YES;
  }
  if (![self.path isEqual:aGetTemporaryLinkArg.path]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetTemporaryLinkArgSerializer

+ (NSDictionary *)serialize:(DBFILESGetTemporaryLinkArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;

  return jsonDict;
}

+ (DBFILESGetTemporaryLinkArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];

  return [[DBFILESGetTemporaryLinkArg alloc] initWithPath:path];
}

@end

#import "DBFILESGetTemporaryLinkError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetTemporaryLinkError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESGetTemporaryLinkErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESGetTemporaryLinkErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESGetTemporaryLinkErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESGetTemporaryLinkErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESGetTemporaryLinkErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESGetTemporaryLinkErrorPath:
    return @"DBFILESGetTemporaryLinkErrorPath";
  case DBFILESGetTemporaryLinkErrorOther:
    return @"DBFILESGetTemporaryLinkErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetTemporaryLinkErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetTemporaryLinkErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetTemporaryLinkErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESGetTemporaryLinkErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESGetTemporaryLinkErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetTemporaryLinkError:other];
}

- (BOOL)isEqualToGetTemporaryLinkError:(DBFILESGetTemporaryLinkError *)aGetTemporaryLinkError {
  if (self == aGetTemporaryLinkError) {
    return YES;
  }
  if (self.tag != aGetTemporaryLinkError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESGetTemporaryLinkErrorPath:
    return [self.path isEqual:aGetTemporaryLinkError.path];
  case DBFILESGetTemporaryLinkErrorOther:
    return [[self tagName] isEqual:[aGetTemporaryLinkError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetTemporaryLinkErrorSerializer

+ (NSDictionary *)serialize:(DBFILESGetTemporaryLinkError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESGetTemporaryLinkError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESGetTemporaryLinkError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESGetTemporaryLinkError alloc] initWithOther];
  } else {
    return [[DBFILESGetTemporaryLinkError alloc] initWithOther];
  }
}

@end

#import "DBFILESFileMetadata.h"
#import "DBFILESGetTemporaryLinkResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGetTemporaryLinkResult

#pragma mark - Constructors

- (instancetype)initWithMetadata:(DBFILESFileMetadata *)metadata link:(NSString *)link {

  self = [super init];
  if (self) {
    _metadata = metadata;
    _link = link;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGetTemporaryLinkResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGetTemporaryLinkResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGetTemporaryLinkResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.metadata hash];
  result = prime * result + [self.link hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGetTemporaryLinkResult:other];
}

- (BOOL)isEqualToGetTemporaryLinkResult:(DBFILESGetTemporaryLinkResult *)aGetTemporaryLinkResult {
  if (self == aGetTemporaryLinkResult) {
    return YES;
  }
  if (![self.metadata isEqual:aGetTemporaryLinkResult.metadata]) {
    return NO;
  }
  if (![self.link isEqual:aGetTemporaryLinkResult.link]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGetTemporaryLinkResultSerializer

+ (NSDictionary *)serialize:(DBFILESGetTemporaryLinkResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"metadata"] = [DBFILESFileMetadataSerializer serialize:valueObj.metadata];
  jsonDict[@"link"] = valueObj.link;

  return jsonDict;
}

+ (DBFILESGetTemporaryLinkResult *)deserialize:(NSDictionary *)valueDict {
  DBFILESFileMetadata *metadata = [DBFILESFileMetadataSerializer deserialize:valueDict[@"metadata"]];
  NSString *link = valueDict[@"link"];

  return [[DBFILESGetTemporaryLinkResult alloc] initWithMetadata:metadata link:link];
}

@end

#import "DBFILESGpsCoordinates.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESGpsCoordinates

#pragma mark - Constructors

- (instancetype)initWithLatitude:(NSNumber *)latitude longitude:(NSNumber *)longitude {

  self = [super init];
  if (self) {
    _latitude = latitude;
    _longitude = longitude;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESGpsCoordinatesSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESGpsCoordinatesSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESGpsCoordinatesSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.latitude hash];
  result = prime * result + [self.longitude hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToGpsCoordinates:other];
}

- (BOOL)isEqualToGpsCoordinates:(DBFILESGpsCoordinates *)aGpsCoordinates {
  if (self == aGpsCoordinates) {
    return YES;
  }
  if (![self.latitude isEqual:aGpsCoordinates.latitude]) {
    return NO;
  }
  if (![self.longitude isEqual:aGpsCoordinates.longitude]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESGpsCoordinatesSerializer

+ (NSDictionary *)serialize:(DBFILESGpsCoordinates *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"latitude"] = valueObj.latitude;
  jsonDict[@"longitude"] = valueObj.longitude;

  return jsonDict;
}

+ (DBFILESGpsCoordinates *)deserialize:(NSDictionary *)valueDict {
  NSNumber *latitude = valueDict[@"latitude"];
  NSNumber *longitude = valueDict[@"longitude"];

  return [[DBFILESGpsCoordinates alloc] initWithLatitude:latitude longitude:longitude];
}

@end

#import "DBFILESListFolderArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                          recursive:(NSNumber *)recursive
                   includeMediaInfo:(NSNumber *)includeMediaInfo
                     includeDeleted:(NSNumber *)includeDeleted
    includeHasExplicitSharedMembers:(NSNumber *)includeHasExplicitSharedMembers {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)?|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
    _recursive = recursive ?: @NO;
    _includeMediaInfo = includeMediaInfo ?: @NO;
    _includeDeleted = includeDeleted ?: @NO;
    _includeHasExplicitSharedMembers = includeHasExplicitSharedMembers ?: @NO;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path
                            recursive:nil
                     includeMediaInfo:nil
                       includeDeleted:nil
      includeHasExplicitSharedMembers:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.recursive hash];
  result = prime * result + [self.includeMediaInfo hash];
  result = prime * result + [self.includeDeleted hash];
  result = prime * result + [self.includeHasExplicitSharedMembers hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderArg:other];
}

- (BOOL)isEqualToListFolderArg:(DBFILESListFolderArg *)aListFolderArg {
  if (self == aListFolderArg) {
    return YES;
  }
  if (![self.path isEqual:aListFolderArg.path]) {
    return NO;
  }
  if (![self.recursive isEqual:aListFolderArg.recursive]) {
    return NO;
  }
  if (![self.includeMediaInfo isEqual:aListFolderArg.includeMediaInfo]) {
    return NO;
  }
  if (![self.includeDeleted isEqual:aListFolderArg.includeDeleted]) {
    return NO;
  }
  if (![self.includeHasExplicitSharedMembers isEqual:aListFolderArg.includeHasExplicitSharedMembers]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderArgSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"recursive"] = valueObj.recursive;
  jsonDict[@"include_media_info"] = valueObj.includeMediaInfo;
  jsonDict[@"include_deleted"] = valueObj.includeDeleted;
  jsonDict[@"include_has_explicit_shared_members"] = valueObj.includeHasExplicitSharedMembers;

  return jsonDict;
}

+ (DBFILESListFolderArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSNumber *recursive = valueDict[@"recursive"] ?: @NO;
  NSNumber *includeMediaInfo = valueDict[@"include_media_info"] ?: @NO;
  NSNumber *includeDeleted = valueDict[@"include_deleted"] ?: @NO;
  NSNumber *includeHasExplicitSharedMembers = valueDict[@"include_has_explicit_shared_members"] ?: @NO;

  return [[DBFILESListFolderArg alloc] initWithPath:path
                                          recursive:recursive
                                   includeMediaInfo:includeMediaInfo
                                     includeDeleted:includeDeleted
                    includeHasExplicitSharedMembers:includeHasExplicitSharedMembers];
}

@end

#import "DBFILESListFolderContinueArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderContinueArg

#pragma mark - Constructors

- (instancetype)initWithCursor:(NSString *)cursor {
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:nil](cursor);

  self = [super init];
  if (self) {
    _cursor = cursor;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderContinueArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderContinueArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderContinueArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.cursor hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderContinueArg:other];
}

- (BOOL)isEqualToListFolderContinueArg:(DBFILESListFolderContinueArg *)aListFolderContinueArg {
  if (self == aListFolderContinueArg) {
    return YES;
  }
  if (![self.cursor isEqual:aListFolderContinueArg.cursor]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderContinueArgSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderContinueArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"cursor"] = valueObj.cursor;

  return jsonDict;
}

+ (DBFILESListFolderContinueArg *)deserialize:(NSDictionary *)valueDict {
  NSString *cursor = valueDict[@"cursor"];

  return [[DBFILESListFolderContinueArg alloc] initWithCursor:cursor];
}

@end

#import "DBFILESListFolderContinueError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderContinueError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderContinueErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithReset {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderContinueErrorReset;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderContinueErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESListFolderContinueErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESListFolderContinueErrorPath;
}

- (BOOL)isReset {
  return _tag == DBFILESListFolderContinueErrorReset;
}

- (BOOL)isOther {
  return _tag == DBFILESListFolderContinueErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESListFolderContinueErrorPath:
    return @"DBFILESListFolderContinueErrorPath";
  case DBFILESListFolderContinueErrorReset:
    return @"DBFILESListFolderContinueErrorReset";
  case DBFILESListFolderContinueErrorOther:
    return @"DBFILESListFolderContinueErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderContinueErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderContinueErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderContinueErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESListFolderContinueErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESListFolderContinueErrorReset:
    result = prime * result + [[self tagName] hash];
  case DBFILESListFolderContinueErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderContinueError:other];
}

- (BOOL)isEqualToListFolderContinueError:(DBFILESListFolderContinueError *)aListFolderContinueError {
  if (self == aListFolderContinueError) {
    return YES;
  }
  if (self.tag != aListFolderContinueError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESListFolderContinueErrorPath:
    return [self.path isEqual:aListFolderContinueError.path];
  case DBFILESListFolderContinueErrorReset:
    return [[self tagName] isEqual:[aListFolderContinueError tagName]];
  case DBFILESListFolderContinueErrorOther:
    return [[self tagName] isEqual:[aListFolderContinueError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderContinueErrorSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderContinueError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isReset]) {
    jsonDict[@".tag"] = @"reset";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESListFolderContinueError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESListFolderContinueError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"reset"]) {
    return [[DBFILESListFolderContinueError alloc] initWithReset];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESListFolderContinueError alloc] initWithOther];
  } else {
    return [[DBFILESListFolderContinueError alloc] initWithOther];
  }
}

@end

#import "DBFILESListFolderError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESListFolderErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESListFolderErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESListFolderErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESListFolderErrorPath:
    return @"DBFILESListFolderErrorPath";
  case DBFILESListFolderErrorOther:
    return @"DBFILESListFolderErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESListFolderErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESListFolderErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderError:other];
}

- (BOOL)isEqualToListFolderError:(DBFILESListFolderError *)aListFolderError {
  if (self == aListFolderError) {
    return YES;
  }
  if (self.tag != aListFolderError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESListFolderErrorPath:
    return [self.path isEqual:aListFolderError.path];
  case DBFILESListFolderErrorOther:
    return [[self tagName] isEqual:[aListFolderError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderErrorSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESListFolderError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESListFolderError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESListFolderError alloc] initWithOther];
  } else {
    return [[DBFILESListFolderError alloc] initWithOther];
  }
}

@end

#import "DBFILESListFolderGetLatestCursorResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderGetLatestCursorResult

#pragma mark - Constructors

- (instancetype)initWithCursor:(NSString *)cursor {
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:nil](cursor);

  self = [super init];
  if (self) {
    _cursor = cursor;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderGetLatestCursorResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderGetLatestCursorResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderGetLatestCursorResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.cursor hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderGetLatestCursorResult:other];
}

- (BOOL)isEqualToListFolderGetLatestCursorResult:
    (DBFILESListFolderGetLatestCursorResult *)aListFolderGetLatestCursorResult {
  if (self == aListFolderGetLatestCursorResult) {
    return YES;
  }
  if (![self.cursor isEqual:aListFolderGetLatestCursorResult.cursor]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderGetLatestCursorResultSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderGetLatestCursorResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"cursor"] = valueObj.cursor;

  return jsonDict;
}

+ (DBFILESListFolderGetLatestCursorResult *)deserialize:(NSDictionary *)valueDict {
  NSString *cursor = valueDict[@"cursor"];

  return [[DBFILESListFolderGetLatestCursorResult alloc] initWithCursor:cursor];
}

@end

#import "DBFILESListFolderLongpollArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderLongpollArg

#pragma mark - Constructors

- (instancetype)initWithCursor:(NSString *)cursor timeout:(NSNumber *)timeout {
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:nil](cursor);
  [DBStoneValidators numericValidator:@(30) maxValue:@(480)](timeout ?: @(30));

  self = [super init];
  if (self) {
    _cursor = cursor;
    _timeout = timeout ?: @(30);
  }
  return self;
}

- (instancetype)initWithCursor:(NSString *)cursor {
  return [self initWithCursor:cursor timeout:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderLongpollArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderLongpollArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderLongpollArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.cursor hash];
  result = prime * result + [self.timeout hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderLongpollArg:other];
}

- (BOOL)isEqualToListFolderLongpollArg:(DBFILESListFolderLongpollArg *)aListFolderLongpollArg {
  if (self == aListFolderLongpollArg) {
    return YES;
  }
  if (![self.cursor isEqual:aListFolderLongpollArg.cursor]) {
    return NO;
  }
  if (![self.timeout isEqual:aListFolderLongpollArg.timeout]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderLongpollArgSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderLongpollArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"cursor"] = valueObj.cursor;
  jsonDict[@"timeout"] = valueObj.timeout;

  return jsonDict;
}

+ (DBFILESListFolderLongpollArg *)deserialize:(NSDictionary *)valueDict {
  NSString *cursor = valueDict[@"cursor"];
  NSNumber *timeout = valueDict[@"timeout"] ?: @(30);

  return [[DBFILESListFolderLongpollArg alloc] initWithCursor:cursor timeout:timeout];
}

@end

#import "DBFILESListFolderLongpollError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderLongpollError

#pragma mark - Constructors

- (instancetype)initWithReset {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderLongpollErrorReset;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESListFolderLongpollErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isReset {
  return _tag == DBFILESListFolderLongpollErrorReset;
}

- (BOOL)isOther {
  return _tag == DBFILESListFolderLongpollErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESListFolderLongpollErrorReset:
    return @"DBFILESListFolderLongpollErrorReset";
  case DBFILESListFolderLongpollErrorOther:
    return @"DBFILESListFolderLongpollErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderLongpollErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderLongpollErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderLongpollErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESListFolderLongpollErrorReset:
    result = prime * result + [[self tagName] hash];
  case DBFILESListFolderLongpollErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderLongpollError:other];
}

- (BOOL)isEqualToListFolderLongpollError:(DBFILESListFolderLongpollError *)aListFolderLongpollError {
  if (self == aListFolderLongpollError) {
    return YES;
  }
  if (self.tag != aListFolderLongpollError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESListFolderLongpollErrorReset:
    return [[self tagName] isEqual:[aListFolderLongpollError tagName]];
  case DBFILESListFolderLongpollErrorOther:
    return [[self tagName] isEqual:[aListFolderLongpollError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderLongpollErrorSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderLongpollError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isReset]) {
    jsonDict[@".tag"] = @"reset";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESListFolderLongpollError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"reset"]) {
    return [[DBFILESListFolderLongpollError alloc] initWithReset];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESListFolderLongpollError alloc] initWithOther];
  } else {
    return [[DBFILESListFolderLongpollError alloc] initWithOther];
  }
}

@end

#import "DBFILESListFolderLongpollResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderLongpollResult

#pragma mark - Constructors

- (instancetype)initWithChanges:(NSNumber *)changes backoff:(NSNumber *)backoff {

  self = [super init];
  if (self) {
    _changes = changes;
    _backoff = backoff;
  }
  return self;
}

- (instancetype)initWithChanges:(NSNumber *)changes {
  return [self initWithChanges:changes backoff:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderLongpollResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderLongpollResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderLongpollResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.changes hash];
  if (self.backoff) {
    result = prime * result + [self.backoff hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderLongpollResult:other];
}

- (BOOL)isEqualToListFolderLongpollResult:(DBFILESListFolderLongpollResult *)aListFolderLongpollResult {
  if (self == aListFolderLongpollResult) {
    return YES;
  }
  if (![self.changes isEqual:aListFolderLongpollResult.changes]) {
    return NO;
  }
  if (self.backoff) {
    if (![self.backoff isEqual:aListFolderLongpollResult.backoff]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderLongpollResultSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderLongpollResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"changes"] = valueObj.changes;
  if (valueObj.backoff) {
    jsonDict[@"backoff"] = valueObj.backoff;
  }

  return jsonDict;
}

+ (DBFILESListFolderLongpollResult *)deserialize:(NSDictionary *)valueDict {
  NSNumber *changes = valueDict[@"changes"];
  NSNumber *backoff = valueDict[@"backoff"] ?: nil;

  return [[DBFILESListFolderLongpollResult alloc] initWithChanges:changes backoff:backoff];
}

@end

#import "DBFILESListFolderResult.h"
#import "DBFILESMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListFolderResult

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESMetadata *> *)entries
                         cursor:(NSString *)cursor
                        hasMore:(NSNumber *)hasMore {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:nil](cursor);

  self = [super init];
  if (self) {
    _entries = entries;
    _cursor = cursor;
    _hasMore = hasMore;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListFolderResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListFolderResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListFolderResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];
  result = prime * result + [self.cursor hash];
  result = prime * result + [self.hasMore hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListFolderResult:other];
}

- (BOOL)isEqualToListFolderResult:(DBFILESListFolderResult *)aListFolderResult {
  if (self == aListFolderResult) {
    return YES;
  }
  if (![self.entries isEqual:aListFolderResult.entries]) {
    return NO;
  }
  if (![self.cursor isEqual:aListFolderResult.cursor]) {
    return NO;
  }
  if (![self.hasMore isEqual:aListFolderResult.hasMore]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListFolderResultSerializer

+ (NSDictionary *)serialize:(DBFILESListFolderResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESMetadataSerializer serialize:elem0];
                                            }];
  jsonDict[@"cursor"] = valueObj.cursor;
  jsonDict[@"has_more"] = valueObj.hasMore;

  return jsonDict;
}

+ (DBFILESListFolderResult *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESMetadata *> *entries = [DBArraySerializer deserialize:valueDict[@"entries"]
                                                             withBlock:^id(id elem0) {
                                                               return [DBFILESMetadataSerializer deserialize:elem0];
                                                             }];
  NSString *cursor = valueDict[@"cursor"];
  NSNumber *hasMore = valueDict[@"has_more"];

  return [[DBFILESListFolderResult alloc] initWithEntries:entries cursor:cursor hasMore:hasMore];
}

@end

#import "DBFILESListRevisionsArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListRevisionsArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path limit:(NSNumber *)limit {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators numericValidator:@(1) maxValue:@(100)](limit ?: @(10));

  self = [super init];
  if (self) {
    _path = path;
    _limit = limit ?: @(10);
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path limit:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListRevisionsArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListRevisionsArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListRevisionsArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.limit hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListRevisionsArg:other];
}

- (BOOL)isEqualToListRevisionsArg:(DBFILESListRevisionsArg *)aListRevisionsArg {
  if (self == aListRevisionsArg) {
    return YES;
  }
  if (![self.path isEqual:aListRevisionsArg.path]) {
    return NO;
  }
  if (![self.limit isEqual:aListRevisionsArg.limit]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListRevisionsArgSerializer

+ (NSDictionary *)serialize:(DBFILESListRevisionsArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"limit"] = valueObj.limit;

  return jsonDict;
}

+ (DBFILESListRevisionsArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSNumber *limit = valueDict[@"limit"] ?: @(10);

  return [[DBFILESListRevisionsArg alloc] initWithPath:path limit:limit];
}

@end

#import "DBFILESListRevisionsError.h"
#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListRevisionsError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESListRevisionsErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESListRevisionsErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESListRevisionsErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESListRevisionsErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESListRevisionsErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESListRevisionsErrorPath:
    return @"DBFILESListRevisionsErrorPath";
  case DBFILESListRevisionsErrorOther:
    return @"DBFILESListRevisionsErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListRevisionsErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListRevisionsErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListRevisionsErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESListRevisionsErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESListRevisionsErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListRevisionsError:other];
}

- (BOOL)isEqualToListRevisionsError:(DBFILESListRevisionsError *)aListRevisionsError {
  if (self == aListRevisionsError) {
    return YES;
  }
  if (self.tag != aListRevisionsError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESListRevisionsErrorPath:
    return [self.path isEqual:aListRevisionsError.path];
  case DBFILESListRevisionsErrorOther:
    return [[self tagName] isEqual:[aListRevisionsError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListRevisionsErrorSerializer

+ (NSDictionary *)serialize:(DBFILESListRevisionsError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESListRevisionsError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESListRevisionsError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESListRevisionsError alloc] initWithOther];
  } else {
    return [[DBFILESListRevisionsError alloc] initWithOther];
  }
}

@end

#import "DBFILESFileMetadata.h"
#import "DBFILESListRevisionsResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESListRevisionsResult

#pragma mark - Constructors

- (instancetype)initWithIsDeleted:(NSNumber *)isDeleted entries:(NSArray<DBFILESFileMetadata *> *)entries {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _isDeleted = isDeleted;
    _entries = entries;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESListRevisionsResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESListRevisionsResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESListRevisionsResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.isDeleted hash];
  result = prime * result + [self.entries hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToListRevisionsResult:other];
}

- (BOOL)isEqualToListRevisionsResult:(DBFILESListRevisionsResult *)aListRevisionsResult {
  if (self == aListRevisionsResult) {
    return YES;
  }
  if (![self.isDeleted isEqual:aListRevisionsResult.isDeleted]) {
    return NO;
  }
  if (![self.entries isEqual:aListRevisionsResult.entries]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESListRevisionsResultSerializer

+ (NSDictionary *)serialize:(DBFILESListRevisionsResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"is_deleted"] = valueObj.isDeleted;
  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESFileMetadataSerializer serialize:elem0];
                                            }];

  return jsonDict;
}

+ (DBFILESListRevisionsResult *)deserialize:(NSDictionary *)valueDict {
  NSNumber *isDeleted = valueDict[@"is_deleted"];
  NSArray<DBFILESFileMetadata *> *entries =
      [DBArraySerializer deserialize:valueDict[@"entries"]
                           withBlock:^id(id elem0) {
                             return [DBFILESFileMetadataSerializer deserialize:elem0];
                           }];

  return [[DBFILESListRevisionsResult alloc] initWithIsDeleted:isDeleted entries:entries];
}

@end

#import "DBFILESLookUpPropertiesError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESLookUpPropertiesError

#pragma mark - Constructors

- (instancetype)initWithPropertyGroupNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESLookUpPropertiesErrorPropertyGroupNotFound;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isPropertyGroupNotFound {
  return _tag == DBFILESLookUpPropertiesErrorPropertyGroupNotFound;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESLookUpPropertiesErrorPropertyGroupNotFound:
    return @"DBFILESLookUpPropertiesErrorPropertyGroupNotFound";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESLookUpPropertiesErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESLookUpPropertiesErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESLookUpPropertiesErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESLookUpPropertiesErrorPropertyGroupNotFound:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToLookUpPropertiesError:other];
}

- (BOOL)isEqualToLookUpPropertiesError:(DBFILESLookUpPropertiesError *)aLookUpPropertiesError {
  if (self == aLookUpPropertiesError) {
    return YES;
  }
  if (self.tag != aLookUpPropertiesError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESLookUpPropertiesErrorPropertyGroupNotFound:
    return [[self tagName] isEqual:[aLookUpPropertiesError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESLookUpPropertiesErrorSerializer

+ (NSDictionary *)serialize:(DBFILESLookUpPropertiesError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPropertyGroupNotFound]) {
    jsonDict[@".tag"] = @"property_group_not_found";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESLookUpPropertiesError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"property_group_not_found"]) {
    return [[DBFILESLookUpPropertiesError alloc] initWithPropertyGroupNotFound];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESLookupError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESLookupError

@synthesize malformedPath = _malformedPath;

#pragma mark - Constructors

- (instancetype)initWithMalformedPath:(NSString *)malformedPath {
  self = [super init];
  if (self) {
    _tag = DBFILESLookupErrorMalformedPath;
    _malformedPath = malformedPath;
  }
  return self;
}

- (instancetype)initWithNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESLookupErrorNotFound;
  }
  return self;
}

- (instancetype)initWithNotFile {
  self = [super init];
  if (self) {
    _tag = DBFILESLookupErrorNotFile;
  }
  return self;
}

- (instancetype)initWithNotFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESLookupErrorNotFolder;
  }
  return self;
}

- (instancetype)initWithRestrictedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESLookupErrorRestrictedContent;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESLookupErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)malformedPath {
  if (![self isMalformedPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESLookupErrorMalformedPath, but was %@.", [self tagName]];
  }
  return _malformedPath;
}

#pragma mark - Tag state methods

- (BOOL)isMalformedPath {
  return _tag == DBFILESLookupErrorMalformedPath;
}

- (BOOL)isNotFound {
  return _tag == DBFILESLookupErrorNotFound;
}

- (BOOL)isNotFile {
  return _tag == DBFILESLookupErrorNotFile;
}

- (BOOL)isNotFolder {
  return _tag == DBFILESLookupErrorNotFolder;
}

- (BOOL)isRestrictedContent {
  return _tag == DBFILESLookupErrorRestrictedContent;
}

- (BOOL)isOther {
  return _tag == DBFILESLookupErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESLookupErrorMalformedPath:
    return @"DBFILESLookupErrorMalformedPath";
  case DBFILESLookupErrorNotFound:
    return @"DBFILESLookupErrorNotFound";
  case DBFILESLookupErrorNotFile:
    return @"DBFILESLookupErrorNotFile";
  case DBFILESLookupErrorNotFolder:
    return @"DBFILESLookupErrorNotFolder";
  case DBFILESLookupErrorRestrictedContent:
    return @"DBFILESLookupErrorRestrictedContent";
  case DBFILESLookupErrorOther:
    return @"DBFILESLookupErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESLookupErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESLookupErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESLookupErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESLookupErrorMalformedPath:
    if (self.malformedPath) {
      result = prime * result + [self.malformedPath hash];
    }
  case DBFILESLookupErrorNotFound:
    result = prime * result + [[self tagName] hash];
  case DBFILESLookupErrorNotFile:
    result = prime * result + [[self tagName] hash];
  case DBFILESLookupErrorNotFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESLookupErrorRestrictedContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESLookupErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToLookupError:other];
}

- (BOOL)isEqualToLookupError:(DBFILESLookupError *)aLookupError {
  if (self == aLookupError) {
    return YES;
  }
  if (self.tag != aLookupError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESLookupErrorMalformedPath:
    if (self.malformedPath) {
      return [self.malformedPath isEqual:aLookupError.malformedPath];
    }
  case DBFILESLookupErrorNotFound:
    return [[self tagName] isEqual:[aLookupError tagName]];
  case DBFILESLookupErrorNotFile:
    return [[self tagName] isEqual:[aLookupError tagName]];
  case DBFILESLookupErrorNotFolder:
    return [[self tagName] isEqual:[aLookupError tagName]];
  case DBFILESLookupErrorRestrictedContent:
    return [[self tagName] isEqual:[aLookupError tagName]];
  case DBFILESLookupErrorOther:
    return [[self tagName] isEqual:[aLookupError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESLookupErrorSerializer

+ (NSDictionary *)serialize:(DBFILESLookupError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isMalformedPath]) {
    if (valueObj.malformedPath) {
      jsonDict[@"malformed_path"] = valueObj.malformedPath;
    }
    jsonDict[@".tag"] = @"malformed_path";
  } else if ([valueObj isNotFound]) {
    jsonDict[@".tag"] = @"not_found";
  } else if ([valueObj isNotFile]) {
    jsonDict[@".tag"] = @"not_file";
  } else if ([valueObj isNotFolder]) {
    jsonDict[@".tag"] = @"not_folder";
  } else if ([valueObj isRestrictedContent]) {
    jsonDict[@".tag"] = @"restricted_content";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESLookupError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"malformed_path"]) {
    NSString *malformedPath = valueDict[@"malformed_path"] ? valueDict[@"malformed_path"] : nil;
    return [[DBFILESLookupError alloc] initWithMalformedPath:malformedPath];
  } else if ([tag isEqualToString:@"not_found"]) {
    return [[DBFILESLookupError alloc] initWithNotFound];
  } else if ([tag isEqualToString:@"not_file"]) {
    return [[DBFILESLookupError alloc] initWithNotFile];
  } else if ([tag isEqualToString:@"not_folder"]) {
    return [[DBFILESLookupError alloc] initWithNotFolder];
  } else if ([tag isEqualToString:@"restricted_content"]) {
    return [[DBFILESLookupError alloc] initWithRestrictedContent];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESLookupError alloc] initWithOther];
  } else {
    return [[DBFILESLookupError alloc] initWithOther];
  }
}

@end

#import "DBFILESMediaInfo.h"
#import "DBFILESMediaMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESMediaInfo

@synthesize metadata = _metadata;

#pragma mark - Constructors

- (instancetype)initWithPending {
  self = [super init];
  if (self) {
    _tag = DBFILESMediaInfoPending;
  }
  return self;
}

- (instancetype)initWithMetadata:(DBFILESMediaMetadata *)metadata {
  self = [super init];
  if (self) {
    _tag = DBFILESMediaInfoMetadata;
    _metadata = metadata;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESMediaMetadata *)metadata {
  if (![self isMetadata]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESMediaInfoMetadata, but was %@.", [self tagName]];
  }
  return _metadata;
}

#pragma mark - Tag state methods

- (BOOL)isPending {
  return _tag == DBFILESMediaInfoPending;
}

- (BOOL)isMetadata {
  return _tag == DBFILESMediaInfoMetadata;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESMediaInfoPending:
    return @"DBFILESMediaInfoPending";
  case DBFILESMediaInfoMetadata:
    return @"DBFILESMediaInfoMetadata";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESMediaInfoSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESMediaInfoSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESMediaInfoSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESMediaInfoPending:
    result = prime * result + [[self tagName] hash];
  case DBFILESMediaInfoMetadata:
    result = prime * result + [self.metadata hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToMediaInfo:other];
}

- (BOOL)isEqualToMediaInfo:(DBFILESMediaInfo *)aMediaInfo {
  if (self == aMediaInfo) {
    return YES;
  }
  if (self.tag != aMediaInfo.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESMediaInfoPending:
    return [[self tagName] isEqual:[aMediaInfo tagName]];
  case DBFILESMediaInfoMetadata:
    return [self.metadata isEqual:aMediaInfo.metadata];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESMediaInfoSerializer

+ (NSDictionary *)serialize:(DBFILESMediaInfo *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPending]) {
    jsonDict[@".tag"] = @"pending";
  } else if ([valueObj isMetadata]) {
    jsonDict[@"metadata"] = [[DBFILESMediaMetadataSerializer serialize:valueObj.metadata] mutableCopy];
    jsonDict[@".tag"] = @"metadata";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESMediaInfo *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"pending"]) {
    return [[DBFILESMediaInfo alloc] initWithPending];
  } else if ([tag isEqualToString:@"metadata"]) {
    DBFILESMediaMetadata *metadata = [DBFILESMediaMetadataSerializer deserialize:valueDict[@"metadata"]];
    return [[DBFILESMediaInfo alloc] initWithMetadata:metadata];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESDimensions.h"
#import "DBFILESGpsCoordinates.h"
#import "DBFILESMediaMetadata.h"
#import "DBFILESPhotoMetadata.h"
#import "DBFILESVideoMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESMediaMetadata

#pragma mark - Constructors

- (instancetype)initWithDimensions:(DBFILESDimensions *)dimensions
                          location:(DBFILESGpsCoordinates *)location
                         timeTaken:(NSDate *)timeTaken {

  self = [super init];
  if (self) {
    _dimensions = dimensions;
    _location = location;
    _timeTaken = timeTaken;
  }
  return self;
}

- (instancetype)initDefault {
  return [self initWithDimensions:nil location:nil timeTaken:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESMediaMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESMediaMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESMediaMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  if (self.dimensions) {
    result = prime * result + [self.dimensions hash];
  }
  if (self.location) {
    result = prime * result + [self.location hash];
  }
  if (self.timeTaken) {
    result = prime * result + [self.timeTaken hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToMediaMetadata:other];
}

- (BOOL)isEqualToMediaMetadata:(DBFILESMediaMetadata *)aMediaMetadata {
  if (self == aMediaMetadata) {
    return YES;
  }
  if (self.dimensions) {
    if (![self.dimensions isEqual:aMediaMetadata.dimensions]) {
      return NO;
    }
  }
  if (self.location) {
    if (![self.location isEqual:aMediaMetadata.location]) {
      return NO;
    }
  }
  if (self.timeTaken) {
    if (![self.timeTaken isEqual:aMediaMetadata.timeTaken]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESMediaMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESMediaMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if (valueObj.dimensions) {
    jsonDict[@"dimensions"] = [DBFILESDimensionsSerializer serialize:valueObj.dimensions];
  }
  if (valueObj.location) {
    jsonDict[@"location"] = [DBFILESGpsCoordinatesSerializer serialize:valueObj.location];
  }
  if (valueObj.timeTaken) {
    jsonDict[@"time_taken"] = [DBNSDateSerializer serialize:valueObj.timeTaken dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  }

  if ([valueObj isKindOfClass:[DBFILESPhotoMetadata class]]) {
    NSDictionary *subTypeFields = [DBFILESPhotoMetadataSerializer serialize:(DBFILESPhotoMetadata *)valueObj];
    for (NSString *key in subTypeFields) {
      jsonDict[key] = subTypeFields[key];
    }
    jsonDict[@".tag"] = @"photo";
  } else if ([valueObj isKindOfClass:[DBFILESVideoMetadata class]]) {
    NSDictionary *subTypeFields = [DBFILESVideoMetadataSerializer serialize:(DBFILESVideoMetadata *)valueObj];
    for (NSString *key in subTypeFields) {
      jsonDict[key] = subTypeFields[key];
    }
    jsonDict[@".tag"] = @"video";
  }

  return jsonDict;
}

+ (DBFILESMediaMetadata *)deserialize:(NSDictionary *)valueDict {
  if ([valueDict[@".tag"] isEqualToString:@"photo"]) {
    return [DBFILESPhotoMetadataSerializer deserialize:valueDict];
  }
  if ([valueDict[@".tag"] isEqualToString:@"video"]) {
    return [DBFILESVideoMetadataSerializer deserialize:valueDict];
  }

  @throw([NSException
      exceptionWithName:@"InvalidTag"
                 reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
               userInfo:nil]);
}

@end

#import "DBFILESDimensions.h"
#import "DBFILESGpsCoordinates.h"
#import "DBFILESMediaMetadata.h"
#import "DBFILESPhotoMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESPhotoMetadata

#pragma mark - Constructors

- (instancetype)initWithDimensions:(DBFILESDimensions *)dimensions
                          location:(DBFILESGpsCoordinates *)location
                         timeTaken:(NSDate *)timeTaken {

  self = [super initWithDimensions:dimensions location:location timeTaken:timeTaken];
  if (self) {
  }
  return self;
}

- (instancetype)initDefault {
  return [self initWithDimensions:nil location:nil timeTaken:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESPhotoMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESPhotoMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESPhotoMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  if (self.dimensions) {
    result = prime * result + [self.dimensions hash];
  }
  if (self.location) {
    result = prime * result + [self.location hash];
  }
  if (self.timeTaken) {
    result = prime * result + [self.timeTaken hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToPhotoMetadata:other];
}

- (BOOL)isEqualToPhotoMetadata:(DBFILESPhotoMetadata *)aPhotoMetadata {
  if (self == aPhotoMetadata) {
    return YES;
  }
  if (self.dimensions) {
    if (![self.dimensions isEqual:aPhotoMetadata.dimensions]) {
      return NO;
    }
  }
  if (self.location) {
    if (![self.location isEqual:aPhotoMetadata.location]) {
      return NO;
    }
  }
  if (self.timeTaken) {
    if (![self.timeTaken isEqual:aPhotoMetadata.timeTaken]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESPhotoMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESPhotoMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if (valueObj.dimensions) {
    jsonDict[@"dimensions"] = [DBFILESDimensionsSerializer serialize:valueObj.dimensions];
  }
  if (valueObj.location) {
    jsonDict[@"location"] = [DBFILESGpsCoordinatesSerializer serialize:valueObj.location];
  }
  if (valueObj.timeTaken) {
    jsonDict[@"time_taken"] = [DBNSDateSerializer serialize:valueObj.timeTaken dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  }

  return jsonDict;
}

+ (DBFILESPhotoMetadata *)deserialize:(NSDictionary *)valueDict {
  DBFILESDimensions *dimensions =
      valueDict[@"dimensions"] ? [DBFILESDimensionsSerializer deserialize:valueDict[@"dimensions"]] : nil;
  DBFILESGpsCoordinates *location =
      valueDict[@"location"] ? [DBFILESGpsCoordinatesSerializer deserialize:valueDict[@"location"]] : nil;
  NSDate *timeTaken = valueDict[@"time_taken"]
                          ? [DBNSDateSerializer deserialize:valueDict[@"time_taken"] dateFormat:@"%Y-%m-%dT%H:%M:%SZ"]
                          : nil;

  return [[DBFILESPhotoMetadata alloc] initWithDimensions:dimensions location:location timeTaken:timeTaken];
}

@end

#import "DBFILESPreviewArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESPreviewArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path rev:(NSString *)rev {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators stringValidator:@(9) maxLength:nil pattern:@"[0-9a-f]+"]](rev);

  self = [super init];
  if (self) {
    _path = path;
    _rev = rev;
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path rev:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESPreviewArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESPreviewArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESPreviewArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  if (self.rev) {
    result = prime * result + [self.rev hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToPreviewArg:other];
}

- (BOOL)isEqualToPreviewArg:(DBFILESPreviewArg *)aPreviewArg {
  if (self == aPreviewArg) {
    return YES;
  }
  if (![self.path isEqual:aPreviewArg.path]) {
    return NO;
  }
  if (self.rev) {
    if (![self.rev isEqual:aPreviewArg.rev]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESPreviewArgSerializer

+ (NSDictionary *)serialize:(DBFILESPreviewArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  if (valueObj.rev) {
    jsonDict[@"rev"] = valueObj.rev;
  }

  return jsonDict;
}

+ (DBFILESPreviewArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSString *rev = valueDict[@"rev"] ?: nil;

  return [[DBFILESPreviewArg alloc] initWithPath:path rev:rev];
}

@end

#import "DBFILESLookupError.h"
#import "DBFILESPreviewError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESPreviewError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESPreviewErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithInProgress {
  self = [super init];
  if (self) {
    _tag = DBFILESPreviewErrorInProgress;
  }
  return self;
}

- (instancetype)initWithUnsupportedExtension {
  self = [super init];
  if (self) {
    _tag = DBFILESPreviewErrorUnsupportedExtension;
  }
  return self;
}

- (instancetype)initWithUnsupportedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESPreviewErrorUnsupportedContent;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESPreviewErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESPreviewErrorPath;
}

- (BOOL)isInProgress {
  return _tag == DBFILESPreviewErrorInProgress;
}

- (BOOL)isUnsupportedExtension {
  return _tag == DBFILESPreviewErrorUnsupportedExtension;
}

- (BOOL)isUnsupportedContent {
  return _tag == DBFILESPreviewErrorUnsupportedContent;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESPreviewErrorPath:
    return @"DBFILESPreviewErrorPath";
  case DBFILESPreviewErrorInProgress:
    return @"DBFILESPreviewErrorInProgress";
  case DBFILESPreviewErrorUnsupportedExtension:
    return @"DBFILESPreviewErrorUnsupportedExtension";
  case DBFILESPreviewErrorUnsupportedContent:
    return @"DBFILESPreviewErrorUnsupportedContent";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESPreviewErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESPreviewErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESPreviewErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESPreviewErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESPreviewErrorInProgress:
    result = prime * result + [[self tagName] hash];
  case DBFILESPreviewErrorUnsupportedExtension:
    result = prime * result + [[self tagName] hash];
  case DBFILESPreviewErrorUnsupportedContent:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToPreviewError:other];
}

- (BOOL)isEqualToPreviewError:(DBFILESPreviewError *)aPreviewError {
  if (self == aPreviewError) {
    return YES;
  }
  if (self.tag != aPreviewError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESPreviewErrorPath:
    return [self.path isEqual:aPreviewError.path];
  case DBFILESPreviewErrorInProgress:
    return [[self tagName] isEqual:[aPreviewError tagName]];
  case DBFILESPreviewErrorUnsupportedExtension:
    return [[self tagName] isEqual:[aPreviewError tagName]];
  case DBFILESPreviewErrorUnsupportedContent:
    return [[self tagName] isEqual:[aPreviewError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESPreviewErrorSerializer

+ (NSDictionary *)serialize:(DBFILESPreviewError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isInProgress]) {
    jsonDict[@".tag"] = @"in_progress";
  } else if ([valueObj isUnsupportedExtension]) {
    jsonDict[@".tag"] = @"unsupported_extension";
  } else if ([valueObj isUnsupportedContent]) {
    jsonDict[@".tag"] = @"unsupported_content";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESPreviewError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESPreviewError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"in_progress"]) {
    return [[DBFILESPreviewError alloc] initWithInProgress];
  } else if ([tag isEqualToString:@"unsupported_extension"]) {
    return [[DBFILESPreviewError alloc] initWithUnsupportedExtension];
  } else if ([tag isEqualToString:@"unsupported_content"]) {
    return [[DBFILESPreviewError alloc] initWithUnsupportedContent];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESPropertyGroupUpdate.h"
#import "DBPROPERTIESPropertyField.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESPropertyGroupUpdate

#pragma mark - Constructors

- (instancetype)initWithTemplateId:(NSString *)templateId
                 addOrUpdateFields:(NSArray<DBPROPERTIESPropertyField *> *)addOrUpdateFields
                      removeFields:(NSArray<NSString *> *)removeFields {
  [DBStoneValidators stringValidator:@(1) maxLength:nil pattern:@"(/|ptid:).*"](templateId);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil]](addOrUpdateFields);
  [DBStoneValidators
   nullableValidator:[DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil]](removeFields);

  self = [super init];
  if (self) {
    _templateId = templateId;
    _addOrUpdateFields = addOrUpdateFields;
    _removeFields = removeFields;
  }
  return self;
}

- (instancetype)initWithTemplateId:(NSString *)templateId {
  return [self initWithTemplateId:templateId addOrUpdateFields:nil removeFields:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESPropertyGroupUpdateSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESPropertyGroupUpdateSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESPropertyGroupUpdateSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.templateId hash];
  if (self.addOrUpdateFields) {
    result = prime * result + [self.addOrUpdateFields hash];
  }
  if (self.removeFields) {
    result = prime * result + [self.removeFields hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToPropertyGroupUpdate:other];
}

- (BOOL)isEqualToPropertyGroupUpdate:(DBFILESPropertyGroupUpdate *)aPropertyGroupUpdate {
  if (self == aPropertyGroupUpdate) {
    return YES;
  }
  if (![self.templateId isEqual:aPropertyGroupUpdate.templateId]) {
    return NO;
  }
  if (self.addOrUpdateFields) {
    if (![self.addOrUpdateFields isEqual:aPropertyGroupUpdate.addOrUpdateFields]) {
      return NO;
    }
  }
  if (self.removeFields) {
    if (![self.removeFields isEqual:aPropertyGroupUpdate.removeFields]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESPropertyGroupUpdateSerializer

+ (NSDictionary *)serialize:(DBFILESPropertyGroupUpdate *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"template_id"] = valueObj.templateId;
  if (valueObj.addOrUpdateFields) {
    jsonDict[@"add_or_update_fields"] =
        [DBArraySerializer serialize:valueObj.addOrUpdateFields
                           withBlock:^id(id elem0) {
                             return [DBPROPERTIESPropertyFieldSerializer serialize:elem0];
                           }];
  }
  if (valueObj.removeFields) {
    jsonDict[@"remove_fields"] = [DBArraySerializer serialize:valueObj.removeFields
                                                    withBlock:^id(id elem0) {
                                                      return elem0;
                                                    }];
  }

  return jsonDict;
}

+ (DBFILESPropertyGroupUpdate *)deserialize:(NSDictionary *)valueDict {
  NSString *templateId = valueDict[@"template_id"];
  NSArray<DBPROPERTIESPropertyField *> *addOrUpdateFields =
      valueDict[@"add_or_update_fields"]
          ? [DBArraySerializer deserialize:valueDict[@"add_or_update_fields"]
                                 withBlock:^id(id elem0) {
                                   return [DBPROPERTIESPropertyFieldSerializer deserialize:elem0];
                                 }]
          : nil;
  NSArray<NSString *> *removeFields = valueDict[@"remove_fields"]
                                          ? [DBArraySerializer deserialize:valueDict[@"remove_fields"]
                                                                 withBlock:^id(id elem0) {
                                                                   return elem0;
                                                                 }]
                                          : nil;

  return [[DBFILESPropertyGroupUpdate alloc] initWithTemplateId:templateId
                                              addOrUpdateFields:addOrUpdateFields
                                                   removeFields:removeFields];
}

@end

#import "DBFILESPropertyGroupWithPath.h"
#import "DBPROPERTIESPropertyGroup.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESPropertyGroupWithPath

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path propertyGroups:(NSArray<DBPROPERTIESPropertyGroup *> *)propertyGroups {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](propertyGroups);

  self = [super init];
  if (self) {
    _path = path;
    _propertyGroups = propertyGroups;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESPropertyGroupWithPathSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESPropertyGroupWithPathSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESPropertyGroupWithPathSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.propertyGroups hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToPropertyGroupWithPath:other];
}

- (BOOL)isEqualToPropertyGroupWithPath:(DBFILESPropertyGroupWithPath *)aPropertyGroupWithPath {
  if (self == aPropertyGroupWithPath) {
    return YES;
  }
  if (![self.path isEqual:aPropertyGroupWithPath.path]) {
    return NO;
  }
  if (![self.propertyGroups isEqual:aPropertyGroupWithPath.propertyGroups]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESPropertyGroupWithPathSerializer

+ (NSDictionary *)serialize:(DBFILESPropertyGroupWithPath *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"property_groups"] = [DBArraySerializer serialize:valueObj.propertyGroups
                                                    withBlock:^id(id elem0) {
                                                      return [DBPROPERTIESPropertyGroupSerializer serialize:elem0];
                                                    }];

  return jsonDict;
}

+ (DBFILESPropertyGroupWithPath *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSArray<DBPROPERTIESPropertyGroup *> *propertyGroups =
      [DBArraySerializer deserialize:valueDict[@"property_groups"]
                           withBlock:^id(id elem0) {
                             return [DBPROPERTIESPropertyGroupSerializer deserialize:elem0];
                           }];

  return [[DBFILESPropertyGroupWithPath alloc] initWithPath:path propertyGroups:propertyGroups];
}

@end

#import "DBFILESRelocationPath.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationPath

#pragma mark - Constructors

- (instancetype)initWithFromPath:(NSString *)fromPath toPath:(NSString *)toPath {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](fromPath);
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](toPath);

  self = [super init];
  if (self) {
    _fromPath = fromPath;
    _toPath = toPath;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationPathSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationPathSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationPathSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.fromPath hash];
  result = prime * result + [self.toPath hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationPath:other];
}

- (BOOL)isEqualToRelocationPath:(DBFILESRelocationPath *)aRelocationPath {
  if (self == aRelocationPath) {
    return YES;
  }
  if (![self.fromPath isEqual:aRelocationPath.fromPath]) {
    return NO;
  }
  if (![self.toPath isEqual:aRelocationPath.toPath]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationPathSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationPath *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"from_path"] = valueObj.fromPath;
  jsonDict[@"to_path"] = valueObj.toPath;

  return jsonDict;
}

+ (DBFILESRelocationPath *)deserialize:(NSDictionary *)valueDict {
  NSString *fromPath = valueDict[@"from_path"];
  NSString *toPath = valueDict[@"to_path"];

  return [[DBFILESRelocationPath alloc] initWithFromPath:fromPath toPath:toPath];
}

@end

#import "DBFILESRelocationArg.h"
#import "DBFILESRelocationPath.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationArg

#pragma mark - Constructors

- (instancetype)initWithFromPath:(NSString *)fromPath
                          toPath:(NSString *)toPath
               allowSharedFolder:(NSNumber *)allowSharedFolder
                      autorename:(NSNumber *)autorename {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](fromPath);
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](toPath);

  self = [super initWithFromPath:fromPath toPath:toPath];
  if (self) {
    _allowSharedFolder = allowSharedFolder ?: @NO;
    _autorename = autorename ?: @NO;
  }
  return self;
}

- (instancetype)initWithFromPath:(NSString *)fromPath toPath:(NSString *)toPath {
  return [self initWithFromPath:fromPath toPath:toPath allowSharedFolder:nil autorename:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.fromPath hash];
  result = prime * result + [self.toPath hash];
  result = prime * result + [self.allowSharedFolder hash];
  result = prime * result + [self.autorename hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationArg:other];
}

- (BOOL)isEqualToRelocationArg:(DBFILESRelocationArg *)aRelocationArg {
  if (self == aRelocationArg) {
    return YES;
  }
  if (![self.fromPath isEqual:aRelocationArg.fromPath]) {
    return NO;
  }
  if (![self.toPath isEqual:aRelocationArg.toPath]) {
    return NO;
  }
  if (![self.allowSharedFolder isEqual:aRelocationArg.allowSharedFolder]) {
    return NO;
  }
  if (![self.autorename isEqual:aRelocationArg.autorename]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationArgSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"from_path"] = valueObj.fromPath;
  jsonDict[@"to_path"] = valueObj.toPath;
  jsonDict[@"allow_shared_folder"] = valueObj.allowSharedFolder;
  jsonDict[@"autorename"] = valueObj.autorename;

  return jsonDict;
}

+ (DBFILESRelocationArg *)deserialize:(NSDictionary *)valueDict {
  NSString *fromPath = valueDict[@"from_path"];
  NSString *toPath = valueDict[@"to_path"];
  NSNumber *allowSharedFolder = valueDict[@"allow_shared_folder"] ?: @NO;
  NSNumber *autorename = valueDict[@"autorename"] ?: @NO;

  return [[DBFILESRelocationArg alloc] initWithFromPath:fromPath
                                                 toPath:toPath
                                      allowSharedFolder:allowSharedFolder
                                             autorename:autorename];
}

@end

#import "DBFILESRelocationBatchArg.h"
#import "DBFILESRelocationPath.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationBatchArg

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESRelocationPath *> *)entries
              allowSharedFolder:(NSNumber *)allowSharedFolder
                     autorename:(NSNumber *)autorename {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _entries = entries;
    _allowSharedFolder = allowSharedFolder ?: @NO;
    _autorename = autorename ?: @NO;
  }
  return self;
}

- (instancetype)initWithEntries:(NSArray<DBFILESRelocationPath *> *)entries {
  return [self initWithEntries:entries allowSharedFolder:nil autorename:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationBatchArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationBatchArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationBatchArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];
  result = prime * result + [self.allowSharedFolder hash];
  result = prime * result + [self.autorename hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationBatchArg:other];
}

- (BOOL)isEqualToRelocationBatchArg:(DBFILESRelocationBatchArg *)aRelocationBatchArg {
  if (self == aRelocationBatchArg) {
    return YES;
  }
  if (![self.entries isEqual:aRelocationBatchArg.entries]) {
    return NO;
  }
  if (![self.allowSharedFolder isEqual:aRelocationBatchArg.allowSharedFolder]) {
    return NO;
  }
  if (![self.autorename isEqual:aRelocationBatchArg.autorename]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationBatchArgSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationBatchArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESRelocationPathSerializer serialize:elem0];
                                            }];
  jsonDict[@"allow_shared_folder"] = valueObj.allowSharedFolder;
  jsonDict[@"autorename"] = valueObj.autorename;

  return jsonDict;
}

+ (DBFILESRelocationBatchArg *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESRelocationPath *> *entries =
      [DBArraySerializer deserialize:valueDict[@"entries"]
                           withBlock:^id(id elem0) {
                             return [DBFILESRelocationPathSerializer deserialize:elem0];
                           }];
  NSNumber *allowSharedFolder = valueDict[@"allow_shared_folder"] ?: @NO;
  NSNumber *autorename = valueDict[@"autorename"] ?: @NO;

  return [[DBFILESRelocationBatchArg alloc] initWithEntries:entries
                                          allowSharedFolder:allowSharedFolder
                                                 autorename:autorename];
}

@end

#import "DBFILESLookupError.h"
#import "DBFILESRelocationError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationError

@synthesize fromLookup = _fromLookup;
@synthesize fromWrite = _fromWrite;
@synthesize to = _to;

#pragma mark - Constructors

- (instancetype)initWithFromLookup:(DBFILESLookupError *)fromLookup {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorFromLookup;
    _fromLookup = fromLookup;
  }
  return self;
}

- (instancetype)initWithFromWrite:(DBFILESWriteError *)fromWrite {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorFromWrite;
    _fromWrite = fromWrite;
  }
  return self;
}

- (instancetype)initWithTo:(DBFILESWriteError *)to {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorTo;
    _to = to;
  }
  return self;
}

- (instancetype)initWithCantCopySharedFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorCantCopySharedFolder;
  }
  return self;
}

- (instancetype)initWithCantNestSharedFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorCantNestSharedFolder;
  }
  return self;
}

- (instancetype)initWithCantMoveFolderIntoItself {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorCantMoveFolderIntoItself;
  }
  return self;
}

- (instancetype)initWithTooManyFiles {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorTooManyFiles;
  }
  return self;
}

- (instancetype)initWithDuplicatedOrNestedPaths {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorDuplicatedOrNestedPaths;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)fromLookup {
  if (![self isFromLookup]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationErrorFromLookup, but was %@.", [self tagName]];
  }
  return _fromLookup;
}

- (DBFILESWriteError *)fromWrite {
  if (![self isFromWrite]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationErrorFromWrite, but was %@.", [self tagName]];
  }
  return _fromWrite;
}

- (DBFILESWriteError *)to {
  if (![self isTo]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationErrorTo, but was %@.", [self tagName]];
  }
  return _to;
}

#pragma mark - Tag state methods

- (BOOL)isFromLookup {
  return _tag == DBFILESRelocationErrorFromLookup;
}

- (BOOL)isFromWrite {
  return _tag == DBFILESRelocationErrorFromWrite;
}

- (BOOL)isTo {
  return _tag == DBFILESRelocationErrorTo;
}

- (BOOL)isCantCopySharedFolder {
  return _tag == DBFILESRelocationErrorCantCopySharedFolder;
}

- (BOOL)isCantNestSharedFolder {
  return _tag == DBFILESRelocationErrorCantNestSharedFolder;
}

- (BOOL)isCantMoveFolderIntoItself {
  return _tag == DBFILESRelocationErrorCantMoveFolderIntoItself;
}

- (BOOL)isTooManyFiles {
  return _tag == DBFILESRelocationErrorTooManyFiles;
}

- (BOOL)isDuplicatedOrNestedPaths {
  return _tag == DBFILESRelocationErrorDuplicatedOrNestedPaths;
}

- (BOOL)isOther {
  return _tag == DBFILESRelocationErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESRelocationErrorFromLookup:
    return @"DBFILESRelocationErrorFromLookup";
  case DBFILESRelocationErrorFromWrite:
    return @"DBFILESRelocationErrorFromWrite";
  case DBFILESRelocationErrorTo:
    return @"DBFILESRelocationErrorTo";
  case DBFILESRelocationErrorCantCopySharedFolder:
    return @"DBFILESRelocationErrorCantCopySharedFolder";
  case DBFILESRelocationErrorCantNestSharedFolder:
    return @"DBFILESRelocationErrorCantNestSharedFolder";
  case DBFILESRelocationErrorCantMoveFolderIntoItself:
    return @"DBFILESRelocationErrorCantMoveFolderIntoItself";
  case DBFILESRelocationErrorTooManyFiles:
    return @"DBFILESRelocationErrorTooManyFiles";
  case DBFILESRelocationErrorDuplicatedOrNestedPaths:
    return @"DBFILESRelocationErrorDuplicatedOrNestedPaths";
  case DBFILESRelocationErrorOther:
    return @"DBFILESRelocationErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESRelocationErrorFromLookup:
    result = prime * result + [self.fromLookup hash];
  case DBFILESRelocationErrorFromWrite:
    result = prime * result + [self.fromWrite hash];
  case DBFILESRelocationErrorTo:
    result = prime * result + [self.to hash];
  case DBFILESRelocationErrorCantCopySharedFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationErrorCantNestSharedFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationErrorCantMoveFolderIntoItself:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationErrorTooManyFiles:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationErrorDuplicatedOrNestedPaths:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationError:other];
}

- (BOOL)isEqualToRelocationError:(DBFILESRelocationError *)aRelocationError {
  if (self == aRelocationError) {
    return YES;
  }
  if (self.tag != aRelocationError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESRelocationErrorFromLookup:
    return [self.fromLookup isEqual:aRelocationError.fromLookup];
  case DBFILESRelocationErrorFromWrite:
    return [self.fromWrite isEqual:aRelocationError.fromWrite];
  case DBFILESRelocationErrorTo:
    return [self.to isEqual:aRelocationError.to];
  case DBFILESRelocationErrorCantCopySharedFolder:
    return [[self tagName] isEqual:[aRelocationError tagName]];
  case DBFILESRelocationErrorCantNestSharedFolder:
    return [[self tagName] isEqual:[aRelocationError tagName]];
  case DBFILESRelocationErrorCantMoveFolderIntoItself:
    return [[self tagName] isEqual:[aRelocationError tagName]];
  case DBFILESRelocationErrorTooManyFiles:
    return [[self tagName] isEqual:[aRelocationError tagName]];
  case DBFILESRelocationErrorDuplicatedOrNestedPaths:
    return [[self tagName] isEqual:[aRelocationError tagName]];
  case DBFILESRelocationErrorOther:
    return [[self tagName] isEqual:[aRelocationError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationErrorSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isFromLookup]) {
    jsonDict[@"from_lookup"] = [[DBFILESLookupErrorSerializer serialize:valueObj.fromLookup] mutableCopy];
    jsonDict[@".tag"] = @"from_lookup";
  } else if ([valueObj isFromWrite]) {
    jsonDict[@"from_write"] = [[DBFILESWriteErrorSerializer serialize:valueObj.fromWrite] mutableCopy];
    jsonDict[@".tag"] = @"from_write";
  } else if ([valueObj isTo]) {
    jsonDict[@"to"] = [[DBFILESWriteErrorSerializer serialize:valueObj.to] mutableCopy];
    jsonDict[@".tag"] = @"to";
  } else if ([valueObj isCantCopySharedFolder]) {
    jsonDict[@".tag"] = @"cant_copy_shared_folder";
  } else if ([valueObj isCantNestSharedFolder]) {
    jsonDict[@".tag"] = @"cant_nest_shared_folder";
  } else if ([valueObj isCantMoveFolderIntoItself]) {
    jsonDict[@".tag"] = @"cant_move_folder_into_itself";
  } else if ([valueObj isTooManyFiles]) {
    jsonDict[@".tag"] = @"too_many_files";
  } else if ([valueObj isDuplicatedOrNestedPaths]) {
    jsonDict[@".tag"] = @"duplicated_or_nested_paths";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESRelocationError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"from_lookup"]) {
    DBFILESLookupError *fromLookup = [DBFILESLookupErrorSerializer deserialize:valueDict[@"from_lookup"]];
    return [[DBFILESRelocationError alloc] initWithFromLookup:fromLookup];
  } else if ([tag isEqualToString:@"from_write"]) {
    DBFILESWriteError *fromWrite = [DBFILESWriteErrorSerializer deserialize:valueDict[@"from_write"]];
    return [[DBFILESRelocationError alloc] initWithFromWrite:fromWrite];
  } else if ([tag isEqualToString:@"to"]) {
    DBFILESWriteError *to = [DBFILESWriteErrorSerializer deserialize:valueDict[@"to"]];
    return [[DBFILESRelocationError alloc] initWithTo:to];
  } else if ([tag isEqualToString:@"cant_copy_shared_folder"]) {
    return [[DBFILESRelocationError alloc] initWithCantCopySharedFolder];
  } else if ([tag isEqualToString:@"cant_nest_shared_folder"]) {
    return [[DBFILESRelocationError alloc] initWithCantNestSharedFolder];
  } else if ([tag isEqualToString:@"cant_move_folder_into_itself"]) {
    return [[DBFILESRelocationError alloc] initWithCantMoveFolderIntoItself];
  } else if ([tag isEqualToString:@"too_many_files"]) {
    return [[DBFILESRelocationError alloc] initWithTooManyFiles];
  } else if ([tag isEqualToString:@"duplicated_or_nested_paths"]) {
    return [[DBFILESRelocationError alloc] initWithDuplicatedOrNestedPaths];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESRelocationError alloc] initWithOther];
  } else {
    return [[DBFILESRelocationError alloc] initWithOther];
  }
}

@end

#import "DBFILESLookupError.h"
#import "DBFILESRelocationBatchError.h"
#import "DBFILESRelocationError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationBatchError

@synthesize fromLookup = _fromLookup;
@synthesize fromWrite = _fromWrite;
@synthesize to = _to;

#pragma mark - Constructors

- (instancetype)initWithFromLookup:(DBFILESLookupError *)fromLookup {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorFromLookup;
    _fromLookup = fromLookup;
  }
  return self;
}

- (instancetype)initWithFromWrite:(DBFILESWriteError *)fromWrite {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorFromWrite;
    _fromWrite = fromWrite;
  }
  return self;
}

- (instancetype)initWithTo:(DBFILESWriteError *)to {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorTo;
    _to = to;
  }
  return self;
}

- (instancetype)initWithCantCopySharedFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorCantCopySharedFolder;
  }
  return self;
}

- (instancetype)initWithCantNestSharedFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorCantNestSharedFolder;
  }
  return self;
}

- (instancetype)initWithCantMoveFolderIntoItself {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorCantMoveFolderIntoItself;
  }
  return self;
}

- (instancetype)initWithTooManyFiles {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorTooManyFiles;
  }
  return self;
}

- (instancetype)initWithDuplicatedOrNestedPaths {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorDuplicatedOrNestedPaths;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorOther;
  }
  return self;
}

- (instancetype)initWithTooManyWriteOperations {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchErrorTooManyWriteOperations;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)fromLookup {
  if (![self isFromLookup]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchErrorFromLookup, but was %@.", [self tagName]];
  }
  return _fromLookup;
}

- (DBFILESWriteError *)fromWrite {
  if (![self isFromWrite]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchErrorFromWrite, but was %@.", [self tagName]];
  }
  return _fromWrite;
}

- (DBFILESWriteError *)to {
  if (![self isTo]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchErrorTo, but was %@.", [self tagName]];
  }
  return _to;
}

#pragma mark - Tag state methods

- (BOOL)isFromLookup {
  return _tag == DBFILESRelocationBatchErrorFromLookup;
}

- (BOOL)isFromWrite {
  return _tag == DBFILESRelocationBatchErrorFromWrite;
}

- (BOOL)isTo {
  return _tag == DBFILESRelocationBatchErrorTo;
}

- (BOOL)isCantCopySharedFolder {
  return _tag == DBFILESRelocationBatchErrorCantCopySharedFolder;
}

- (BOOL)isCantNestSharedFolder {
  return _tag == DBFILESRelocationBatchErrorCantNestSharedFolder;
}

- (BOOL)isCantMoveFolderIntoItself {
  return _tag == DBFILESRelocationBatchErrorCantMoveFolderIntoItself;
}

- (BOOL)isTooManyFiles {
  return _tag == DBFILESRelocationBatchErrorTooManyFiles;
}

- (BOOL)isDuplicatedOrNestedPaths {
  return _tag == DBFILESRelocationBatchErrorDuplicatedOrNestedPaths;
}

- (BOOL)isOther {
  return _tag == DBFILESRelocationBatchErrorOther;
}

- (BOOL)isTooManyWriteOperations {
  return _tag == DBFILESRelocationBatchErrorTooManyWriteOperations;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESRelocationBatchErrorFromLookup:
    return @"DBFILESRelocationBatchErrorFromLookup";
  case DBFILESRelocationBatchErrorFromWrite:
    return @"DBFILESRelocationBatchErrorFromWrite";
  case DBFILESRelocationBatchErrorTo:
    return @"DBFILESRelocationBatchErrorTo";
  case DBFILESRelocationBatchErrorCantCopySharedFolder:
    return @"DBFILESRelocationBatchErrorCantCopySharedFolder";
  case DBFILESRelocationBatchErrorCantNestSharedFolder:
    return @"DBFILESRelocationBatchErrorCantNestSharedFolder";
  case DBFILESRelocationBatchErrorCantMoveFolderIntoItself:
    return @"DBFILESRelocationBatchErrorCantMoveFolderIntoItself";
  case DBFILESRelocationBatchErrorTooManyFiles:
    return @"DBFILESRelocationBatchErrorTooManyFiles";
  case DBFILESRelocationBatchErrorDuplicatedOrNestedPaths:
    return @"DBFILESRelocationBatchErrorDuplicatedOrNestedPaths";
  case DBFILESRelocationBatchErrorOther:
    return @"DBFILESRelocationBatchErrorOther";
  case DBFILESRelocationBatchErrorTooManyWriteOperations:
    return @"DBFILESRelocationBatchErrorTooManyWriteOperations";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationBatchErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationBatchErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationBatchErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESRelocationBatchErrorFromLookup:
    result = prime * result + [self.fromLookup hash];
  case DBFILESRelocationBatchErrorFromWrite:
    result = prime * result + [self.fromWrite hash];
  case DBFILESRelocationBatchErrorTo:
    result = prime * result + [self.to hash];
  case DBFILESRelocationBatchErrorCantCopySharedFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchErrorCantNestSharedFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchErrorCantMoveFolderIntoItself:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchErrorTooManyFiles:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchErrorDuplicatedOrNestedPaths:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchErrorOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchErrorTooManyWriteOperations:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationBatchError:other];
}

- (BOOL)isEqualToRelocationBatchError:(DBFILESRelocationBatchError *)aRelocationBatchError {
  if (self == aRelocationBatchError) {
    return YES;
  }
  if (self.tag != aRelocationBatchError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESRelocationBatchErrorFromLookup:
    return [self.fromLookup isEqual:aRelocationBatchError.fromLookup];
  case DBFILESRelocationBatchErrorFromWrite:
    return [self.fromWrite isEqual:aRelocationBatchError.fromWrite];
  case DBFILESRelocationBatchErrorTo:
    return [self.to isEqual:aRelocationBatchError.to];
  case DBFILESRelocationBatchErrorCantCopySharedFolder:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  case DBFILESRelocationBatchErrorCantNestSharedFolder:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  case DBFILESRelocationBatchErrorCantMoveFolderIntoItself:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  case DBFILESRelocationBatchErrorTooManyFiles:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  case DBFILESRelocationBatchErrorDuplicatedOrNestedPaths:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  case DBFILESRelocationBatchErrorOther:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  case DBFILESRelocationBatchErrorTooManyWriteOperations:
    return [[self tagName] isEqual:[aRelocationBatchError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationBatchErrorSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationBatchError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isFromLookup]) {
    jsonDict[@"from_lookup"] = [[DBFILESLookupErrorSerializer serialize:valueObj.fromLookup] mutableCopy];
    jsonDict[@".tag"] = @"from_lookup";
  } else if ([valueObj isFromWrite]) {
    jsonDict[@"from_write"] = [[DBFILESWriteErrorSerializer serialize:valueObj.fromWrite] mutableCopy];
    jsonDict[@".tag"] = @"from_write";
  } else if ([valueObj isTo]) {
    jsonDict[@"to"] = [[DBFILESWriteErrorSerializer serialize:valueObj.to] mutableCopy];
    jsonDict[@".tag"] = @"to";
  } else if ([valueObj isCantCopySharedFolder]) {
    jsonDict[@".tag"] = @"cant_copy_shared_folder";
  } else if ([valueObj isCantNestSharedFolder]) {
    jsonDict[@".tag"] = @"cant_nest_shared_folder";
  } else if ([valueObj isCantMoveFolderIntoItself]) {
    jsonDict[@".tag"] = @"cant_move_folder_into_itself";
  } else if ([valueObj isTooManyFiles]) {
    jsonDict[@".tag"] = @"too_many_files";
  } else if ([valueObj isDuplicatedOrNestedPaths]) {
    jsonDict[@".tag"] = @"duplicated_or_nested_paths";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isTooManyWriteOperations]) {
    jsonDict[@".tag"] = @"too_many_write_operations";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESRelocationBatchError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"from_lookup"]) {
    DBFILESLookupError *fromLookup = [DBFILESLookupErrorSerializer deserialize:valueDict[@"from_lookup"]];
    return [[DBFILESRelocationBatchError alloc] initWithFromLookup:fromLookup];
  } else if ([tag isEqualToString:@"from_write"]) {
    DBFILESWriteError *fromWrite = [DBFILESWriteErrorSerializer deserialize:valueDict[@"from_write"]];
    return [[DBFILESRelocationBatchError alloc] initWithFromWrite:fromWrite];
  } else if ([tag isEqualToString:@"to"]) {
    DBFILESWriteError *to = [DBFILESWriteErrorSerializer deserialize:valueDict[@"to"]];
    return [[DBFILESRelocationBatchError alloc] initWithTo:to];
  } else if ([tag isEqualToString:@"cant_copy_shared_folder"]) {
    return [[DBFILESRelocationBatchError alloc] initWithCantCopySharedFolder];
  } else if ([tag isEqualToString:@"cant_nest_shared_folder"]) {
    return [[DBFILESRelocationBatchError alloc] initWithCantNestSharedFolder];
  } else if ([tag isEqualToString:@"cant_move_folder_into_itself"]) {
    return [[DBFILESRelocationBatchError alloc] initWithCantMoveFolderIntoItself];
  } else if ([tag isEqualToString:@"too_many_files"]) {
    return [[DBFILESRelocationBatchError alloc] initWithTooManyFiles];
  } else if ([tag isEqualToString:@"duplicated_or_nested_paths"]) {
    return [[DBFILESRelocationBatchError alloc] initWithDuplicatedOrNestedPaths];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESRelocationBatchError alloc] initWithOther];
  } else if ([tag isEqualToString:@"too_many_write_operations"]) {
    return [[DBFILESRelocationBatchError alloc] initWithTooManyWriteOperations];
  } else {
    return [[DBFILESRelocationBatchError alloc] initWithOther];
  }
}

@end

#import "DBASYNCPollResultBase.h"
#import "DBFILESRelocationBatchError.h"
#import "DBFILESRelocationBatchJobStatus.h"
#import "DBFILESRelocationBatchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationBatchJobStatus

@synthesize complete = _complete;
@synthesize failed = _failed;

#pragma mark - Constructors

- (instancetype)initWithInProgress {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchJobStatusInProgress;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESRelocationBatchResult *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchJobStatusComplete;
    _complete = complete;
  }
  return self;
}

- (instancetype)initWithFailed:(DBFILESRelocationBatchError *)failed {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchJobStatusFailed;
    _failed = failed;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESRelocationBatchResult *)complete {
  if (![self isComplete]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchJobStatusComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

- (DBFILESRelocationBatchError *)failed {
  if (![self isFailed]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchJobStatusFailed, but was %@.", [self tagName]];
  }
  return _failed;
}

#pragma mark - Tag state methods

- (BOOL)isInProgress {
  return _tag == DBFILESRelocationBatchJobStatusInProgress;
}

- (BOOL)isComplete {
  return _tag == DBFILESRelocationBatchJobStatusComplete;
}

- (BOOL)isFailed {
  return _tag == DBFILESRelocationBatchJobStatusFailed;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESRelocationBatchJobStatusInProgress:
    return @"DBFILESRelocationBatchJobStatusInProgress";
  case DBFILESRelocationBatchJobStatusComplete:
    return @"DBFILESRelocationBatchJobStatusComplete";
  case DBFILESRelocationBatchJobStatusFailed:
    return @"DBFILESRelocationBatchJobStatusFailed";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationBatchJobStatusSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationBatchJobStatusSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationBatchJobStatusSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESRelocationBatchJobStatusInProgress:
    result = prime * result + [[self tagName] hash];
  case DBFILESRelocationBatchJobStatusComplete:
    result = prime * result + [self.complete hash];
  case DBFILESRelocationBatchJobStatusFailed:
    result = prime * result + [self.failed hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationBatchJobStatus:other];
}

- (BOOL)isEqualToRelocationBatchJobStatus:(DBFILESRelocationBatchJobStatus *)aRelocationBatchJobStatus {
  if (self == aRelocationBatchJobStatus) {
    return YES;
  }
  if (self.tag != aRelocationBatchJobStatus.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESRelocationBatchJobStatusInProgress:
    return [[self tagName] isEqual:[aRelocationBatchJobStatus tagName]];
  case DBFILESRelocationBatchJobStatusComplete:
    return [self.complete isEqual:aRelocationBatchJobStatus.complete];
  case DBFILESRelocationBatchJobStatusFailed:
    return [self.failed isEqual:aRelocationBatchJobStatus.failed];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationBatchJobStatusSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationBatchJobStatus *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isInProgress]) {
    jsonDict[@".tag"] = @"in_progress";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESRelocationBatchResultSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else if ([valueObj isFailed]) {
    jsonDict[@"failed"] = [[DBFILESRelocationBatchErrorSerializer serialize:valueObj.failed] mutableCopy];
    jsonDict[@".tag"] = @"failed";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESRelocationBatchJobStatus *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"in_progress"]) {
    return [[DBFILESRelocationBatchJobStatus alloc] initWithInProgress];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESRelocationBatchResult *complete = [DBFILESRelocationBatchResultSerializer deserialize:valueDict];
    return [[DBFILESRelocationBatchJobStatus alloc] initWithComplete:complete];
  } else if ([tag isEqualToString:@"failed"]) {
    DBFILESRelocationBatchError *failed = [DBFILESRelocationBatchErrorSerializer deserialize:valueDict[@"failed"]];
    return [[DBFILESRelocationBatchJobStatus alloc] initWithFailed:failed];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBASYNCLaunchResultBase.h"
#import "DBFILESRelocationBatchLaunch.h"
#import "DBFILESRelocationBatchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationBatchLaunch

@synthesize asyncJobId = _asyncJobId;
@synthesize complete = _complete;

#pragma mark - Constructors

- (instancetype)initWithAsyncJobId:(NSString *)asyncJobId {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchLaunchAsyncJobId;
    _asyncJobId = asyncJobId;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESRelocationBatchResult *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchLaunchComplete;
    _complete = complete;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESRelocationBatchLaunchOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)asyncJobId {
  if (![self isAsyncJobId]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchLaunchAsyncJobId, but was %@.", [self tagName]];
  }
  return _asyncJobId;
}

- (DBFILESRelocationBatchResult *)complete {
  if (![self isComplete]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRelocationBatchLaunchComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

#pragma mark - Tag state methods

- (BOOL)isAsyncJobId {
  return _tag == DBFILESRelocationBatchLaunchAsyncJobId;
}

- (BOOL)isComplete {
  return _tag == DBFILESRelocationBatchLaunchComplete;
}

- (BOOL)isOther {
  return _tag == DBFILESRelocationBatchLaunchOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESRelocationBatchLaunchAsyncJobId:
    return @"DBFILESRelocationBatchLaunchAsyncJobId";
  case DBFILESRelocationBatchLaunchComplete:
    return @"DBFILESRelocationBatchLaunchComplete";
  case DBFILESRelocationBatchLaunchOther:
    return @"DBFILESRelocationBatchLaunchOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationBatchLaunchSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationBatchLaunchSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationBatchLaunchSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESRelocationBatchLaunchAsyncJobId:
    result = prime * result + [self.asyncJobId hash];
  case DBFILESRelocationBatchLaunchComplete:
    result = prime * result + [self.complete hash];
  case DBFILESRelocationBatchLaunchOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationBatchLaunch:other];
}

- (BOOL)isEqualToRelocationBatchLaunch:(DBFILESRelocationBatchLaunch *)aRelocationBatchLaunch {
  if (self == aRelocationBatchLaunch) {
    return YES;
  }
  if (self.tag != aRelocationBatchLaunch.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESRelocationBatchLaunchAsyncJobId:
    return [self.asyncJobId isEqual:aRelocationBatchLaunch.asyncJobId];
  case DBFILESRelocationBatchLaunchComplete:
    return [self.complete isEqual:aRelocationBatchLaunch.complete];
  case DBFILESRelocationBatchLaunchOther:
    return [[self tagName] isEqual:[aRelocationBatchLaunch tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationBatchLaunchSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationBatchLaunch *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isAsyncJobId]) {
    jsonDict[@"async_job_id"] = valueObj.asyncJobId;
    jsonDict[@".tag"] = @"async_job_id";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESRelocationBatchResultSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESRelocationBatchLaunch *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"async_job_id"]) {
    NSString *asyncJobId = valueDict[@"async_job_id"];
    return [[DBFILESRelocationBatchLaunch alloc] initWithAsyncJobId:asyncJobId];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESRelocationBatchResult *complete = [DBFILESRelocationBatchResultSerializer deserialize:valueDict];
    return [[DBFILESRelocationBatchLaunch alloc] initWithComplete:complete];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESRelocationBatchLaunch alloc] initWithOther];
  } else {
    return [[DBFILESRelocationBatchLaunch alloc] initWithOther];
  }
}

@end

#import "DBFILESRelocationBatchResult.h"
#import "DBFILESRelocationResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationBatchResult

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESRelocationResult *> *)entries {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _entries = entries;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationBatchResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationBatchResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationBatchResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationBatchResult:other];
}

- (BOOL)isEqualToRelocationBatchResult:(DBFILESRelocationBatchResult *)aRelocationBatchResult {
  if (self == aRelocationBatchResult) {
    return YES;
  }
  if (![self.entries isEqual:aRelocationBatchResult.entries]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationBatchResultSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationBatchResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESRelocationResultSerializer serialize:elem0];
                                            }];

  return jsonDict;
}

+ (DBFILESRelocationBatchResult *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESRelocationResult *> *entries =
      [DBArraySerializer deserialize:valueDict[@"entries"]
                           withBlock:^id(id elem0) {
                             return [DBFILESRelocationResultSerializer deserialize:elem0];
                           }];

  return [[DBFILESRelocationBatchResult alloc] initWithEntries:entries];
}

@end

#import "DBFILESMetadata.h"
#import "DBFILESRelocationResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRelocationResult

#pragma mark - Constructors

- (instancetype)initWithMetadata:(DBFILESMetadata *)metadata {

  self = [super init];
  if (self) {
    _metadata = metadata;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRelocationResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRelocationResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRelocationResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.metadata hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRelocationResult:other];
}

- (BOOL)isEqualToRelocationResult:(DBFILESRelocationResult *)aRelocationResult {
  if (self == aRelocationResult) {
    return YES;
  }
  if (![self.metadata isEqual:aRelocationResult.metadata]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRelocationResultSerializer

+ (NSDictionary *)serialize:(DBFILESRelocationResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"metadata"] = [DBFILESMetadataSerializer serialize:valueObj.metadata];

  return jsonDict;
}

+ (DBFILESRelocationResult *)deserialize:(NSDictionary *)valueDict {
  DBFILESMetadata *metadata = [DBFILESMetadataSerializer deserialize:valueDict[@"metadata"]];

  return [[DBFILESRelocationResult alloc] initWithMetadata:metadata];
}

@end

#import "DBFILESRemovePropertiesArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRemovePropertiesArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path propertyTemplateIds:(NSArray<NSString *> *)propertyTemplateIds {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators arrayValidator:nil maxItems:nil
                      itemValidator:[DBStoneValidators stringValidator:@(1) maxLength:nil pattern:@"(/|ptid:).*"]](
      propertyTemplateIds);

  self = [super init];
  if (self) {
    _path = path;
    _propertyTemplateIds = propertyTemplateIds;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRemovePropertiesArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRemovePropertiesArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRemovePropertiesArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.propertyTemplateIds hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRemovePropertiesArg:other];
}

- (BOOL)isEqualToRemovePropertiesArg:(DBFILESRemovePropertiesArg *)aRemovePropertiesArg {
  if (self == aRemovePropertiesArg) {
    return YES;
  }
  if (![self.path isEqual:aRemovePropertiesArg.path]) {
    return NO;
  }
  if (![self.propertyTemplateIds isEqual:aRemovePropertiesArg.propertyTemplateIds]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRemovePropertiesArgSerializer

+ (NSDictionary *)serialize:(DBFILESRemovePropertiesArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"property_template_ids"] = [DBArraySerializer serialize:valueObj.propertyTemplateIds
                                                          withBlock:^id(id elem0) {
                                                            return elem0;
                                                          }];

  return jsonDict;
}

+ (DBFILESRemovePropertiesArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSArray<NSString *> *propertyTemplateIds = [DBArraySerializer deserialize:valueDict[@"property_template_ids"]
                                                                  withBlock:^id(id elem0) {
                                                                    return elem0;
                                                                  }];

  return [[DBFILESRemovePropertiesArg alloc] initWithPath:path propertyTemplateIds:propertyTemplateIds];
}

@end

#import "DBFILESLookUpPropertiesError.h"
#import "DBFILESLookupError.h"
#import "DBFILESPropertiesError.h"
#import "DBFILESRemovePropertiesError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRemovePropertiesError

@synthesize templateNotFound = _templateNotFound;
@synthesize path = _path;
@synthesize propertyGroupLookup = _propertyGroupLookup;

#pragma mark - Constructors

- (instancetype)initWithTemplateNotFound:(NSString *)templateNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESRemovePropertiesErrorTemplateNotFound;
    _templateNotFound = templateNotFound;
  }
  return self;
}

- (instancetype)initWithRestrictedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESRemovePropertiesErrorRestrictedContent;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESRemovePropertiesErrorOther;
  }
  return self;
}

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESRemovePropertiesErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithPropertyGroupLookup:(DBFILESLookUpPropertiesError *)propertyGroupLookup {
  self = [super init];
  if (self) {
    _tag = DBFILESRemovePropertiesErrorPropertyGroupLookup;
    _propertyGroupLookup = propertyGroupLookup;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)templateNotFound {
  if (![self isTemplateNotFound]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESRemovePropertiesErrorTemplateNotFound, but was %@.", [self tagName]];
  }
  return _templateNotFound;
}

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRemovePropertiesErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

- (DBFILESLookUpPropertiesError *)propertyGroupLookup {
  if (![self isPropertyGroupLookup]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESRemovePropertiesErrorPropertyGroupLookup, but was %@.", [self tagName]];
  }
  return _propertyGroupLookup;
}

#pragma mark - Tag state methods

- (BOOL)isTemplateNotFound {
  return _tag == DBFILESRemovePropertiesErrorTemplateNotFound;
}

- (BOOL)isRestrictedContent {
  return _tag == DBFILESRemovePropertiesErrorRestrictedContent;
}

- (BOOL)isOther {
  return _tag == DBFILESRemovePropertiesErrorOther;
}

- (BOOL)isPath {
  return _tag == DBFILESRemovePropertiesErrorPath;
}

- (BOOL)isPropertyGroupLookup {
  return _tag == DBFILESRemovePropertiesErrorPropertyGroupLookup;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESRemovePropertiesErrorTemplateNotFound:
    return @"DBFILESRemovePropertiesErrorTemplateNotFound";
  case DBFILESRemovePropertiesErrorRestrictedContent:
    return @"DBFILESRemovePropertiesErrorRestrictedContent";
  case DBFILESRemovePropertiesErrorOther:
    return @"DBFILESRemovePropertiesErrorOther";
  case DBFILESRemovePropertiesErrorPath:
    return @"DBFILESRemovePropertiesErrorPath";
  case DBFILESRemovePropertiesErrorPropertyGroupLookup:
    return @"DBFILESRemovePropertiesErrorPropertyGroupLookup";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRemovePropertiesErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRemovePropertiesErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRemovePropertiesErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESRemovePropertiesErrorTemplateNotFound:
    result = prime * result + [self.templateNotFound hash];
  case DBFILESRemovePropertiesErrorRestrictedContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESRemovePropertiesErrorOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESRemovePropertiesErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESRemovePropertiesErrorPropertyGroupLookup:
    result = prime * result + [self.propertyGroupLookup hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRemovePropertiesError:other];
}

- (BOOL)isEqualToRemovePropertiesError:(DBFILESRemovePropertiesError *)aRemovePropertiesError {
  if (self == aRemovePropertiesError) {
    return YES;
  }
  if (self.tag != aRemovePropertiesError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESRemovePropertiesErrorTemplateNotFound:
    return [self.templateNotFound isEqual:aRemovePropertiesError.templateNotFound];
  case DBFILESRemovePropertiesErrorRestrictedContent:
    return [[self tagName] isEqual:[aRemovePropertiesError tagName]];
  case DBFILESRemovePropertiesErrorOther:
    return [[self tagName] isEqual:[aRemovePropertiesError tagName]];
  case DBFILESRemovePropertiesErrorPath:
    return [self.path isEqual:aRemovePropertiesError.path];
  case DBFILESRemovePropertiesErrorPropertyGroupLookup:
    return [self.propertyGroupLookup isEqual:aRemovePropertiesError.propertyGroupLookup];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRemovePropertiesErrorSerializer

+ (NSDictionary *)serialize:(DBFILESRemovePropertiesError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isTemplateNotFound]) {
    jsonDict[@"template_not_found"] = valueObj.templateNotFound;
    jsonDict[@".tag"] = @"template_not_found";
  } else if ([valueObj isRestrictedContent]) {
    jsonDict[@".tag"] = @"restricted_content";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isPropertyGroupLookup]) {
    jsonDict[@"property_group_lookup"] =
        [[DBFILESLookUpPropertiesErrorSerializer serialize:valueObj.propertyGroupLookup] mutableCopy];
    jsonDict[@".tag"] = @"property_group_lookup";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESRemovePropertiesError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"template_not_found"]) {
    NSString *templateNotFound = valueDict[@"template_not_found"];
    return [[DBFILESRemovePropertiesError alloc] initWithTemplateNotFound:templateNotFound];
  } else if ([tag isEqualToString:@"restricted_content"]) {
    return [[DBFILESRemovePropertiesError alloc] initWithRestrictedContent];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESRemovePropertiesError alloc] initWithOther];
  } else if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESRemovePropertiesError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"property_group_lookup"]) {
    DBFILESLookUpPropertiesError *propertyGroupLookup =
        [DBFILESLookUpPropertiesErrorSerializer deserialize:valueDict[@"property_group_lookup"]];
    return [[DBFILESRemovePropertiesError alloc] initWithPropertyGroupLookup:propertyGroupLookup];
  } else {
    return [[DBFILESRemovePropertiesError alloc] initWithOther];
  }
}

@end

#import "DBFILESRestoreArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRestoreArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path rev:(NSString *)rev {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators stringValidator:@(9) maxLength:nil pattern:@"[0-9a-f]+"](rev);

  self = [super init];
  if (self) {
    _path = path;
    _rev = rev;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRestoreArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRestoreArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRestoreArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.rev hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRestoreArg:other];
}

- (BOOL)isEqualToRestoreArg:(DBFILESRestoreArg *)aRestoreArg {
  if (self == aRestoreArg) {
    return YES;
  }
  if (![self.path isEqual:aRestoreArg.path]) {
    return NO;
  }
  if (![self.rev isEqual:aRestoreArg.rev]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRestoreArgSerializer

+ (NSDictionary *)serialize:(DBFILESRestoreArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"rev"] = valueObj.rev;

  return jsonDict;
}

+ (DBFILESRestoreArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSString *rev = valueDict[@"rev"];

  return [[DBFILESRestoreArg alloc] initWithPath:path rev:rev];
}

@end

#import "DBFILESLookupError.h"
#import "DBFILESRestoreError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESRestoreError

@synthesize pathLookup = _pathLookup;
@synthesize pathWrite = _pathWrite;

#pragma mark - Constructors

- (instancetype)initWithPathLookup:(DBFILESLookupError *)pathLookup {
  self = [super init];
  if (self) {
    _tag = DBFILESRestoreErrorPathLookup;
    _pathLookup = pathLookup;
  }
  return self;
}

- (instancetype)initWithPathWrite:(DBFILESWriteError *)pathWrite {
  self = [super init];
  if (self) {
    _tag = DBFILESRestoreErrorPathWrite;
    _pathWrite = pathWrite;
  }
  return self;
}

- (instancetype)initWithInvalidRevision {
  self = [super init];
  if (self) {
    _tag = DBFILESRestoreErrorInvalidRevision;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESRestoreErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)pathLookup {
  if (![self isPathLookup]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRestoreErrorPathLookup, but was %@.", [self tagName]];
  }
  return _pathLookup;
}

- (DBFILESWriteError *)pathWrite {
  if (![self isPathWrite]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESRestoreErrorPathWrite, but was %@.", [self tagName]];
  }
  return _pathWrite;
}

#pragma mark - Tag state methods

- (BOOL)isPathLookup {
  return _tag == DBFILESRestoreErrorPathLookup;
}

- (BOOL)isPathWrite {
  return _tag == DBFILESRestoreErrorPathWrite;
}

- (BOOL)isInvalidRevision {
  return _tag == DBFILESRestoreErrorInvalidRevision;
}

- (BOOL)isOther {
  return _tag == DBFILESRestoreErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESRestoreErrorPathLookup:
    return @"DBFILESRestoreErrorPathLookup";
  case DBFILESRestoreErrorPathWrite:
    return @"DBFILESRestoreErrorPathWrite";
  case DBFILESRestoreErrorInvalidRevision:
    return @"DBFILESRestoreErrorInvalidRevision";
  case DBFILESRestoreErrorOther:
    return @"DBFILESRestoreErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESRestoreErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESRestoreErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESRestoreErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESRestoreErrorPathLookup:
    result = prime * result + [self.pathLookup hash];
  case DBFILESRestoreErrorPathWrite:
    result = prime * result + [self.pathWrite hash];
  case DBFILESRestoreErrorInvalidRevision:
    result = prime * result + [[self tagName] hash];
  case DBFILESRestoreErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToRestoreError:other];
}

- (BOOL)isEqualToRestoreError:(DBFILESRestoreError *)aRestoreError {
  if (self == aRestoreError) {
    return YES;
  }
  if (self.tag != aRestoreError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESRestoreErrorPathLookup:
    return [self.pathLookup isEqual:aRestoreError.pathLookup];
  case DBFILESRestoreErrorPathWrite:
    return [self.pathWrite isEqual:aRestoreError.pathWrite];
  case DBFILESRestoreErrorInvalidRevision:
    return [[self tagName] isEqual:[aRestoreError tagName]];
  case DBFILESRestoreErrorOther:
    return [[self tagName] isEqual:[aRestoreError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESRestoreErrorSerializer

+ (NSDictionary *)serialize:(DBFILESRestoreError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPathLookup]) {
    jsonDict[@"path_lookup"] = [[DBFILESLookupErrorSerializer serialize:valueObj.pathLookup] mutableCopy];
    jsonDict[@".tag"] = @"path_lookup";
  } else if ([valueObj isPathWrite]) {
    jsonDict[@"path_write"] = [[DBFILESWriteErrorSerializer serialize:valueObj.pathWrite] mutableCopy];
    jsonDict[@".tag"] = @"path_write";
  } else if ([valueObj isInvalidRevision]) {
    jsonDict[@".tag"] = @"invalid_revision";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESRestoreError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path_lookup"]) {
    DBFILESLookupError *pathLookup = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path_lookup"]];
    return [[DBFILESRestoreError alloc] initWithPathLookup:pathLookup];
  } else if ([tag isEqualToString:@"path_write"]) {
    DBFILESWriteError *pathWrite = [DBFILESWriteErrorSerializer deserialize:valueDict[@"path_write"]];
    return [[DBFILESRestoreError alloc] initWithPathWrite:pathWrite];
  } else if ([tag isEqualToString:@"invalid_revision"]) {
    return [[DBFILESRestoreError alloc] initWithInvalidRevision];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESRestoreError alloc] initWithOther];
  } else {
    return [[DBFILESRestoreError alloc] initWithOther];
  }
}

@end

#import "DBFILESSaveCopyReferenceArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveCopyReferenceArg

#pragma mark - Constructors

- (instancetype)initWithDCopyReference:(NSString *)dCopyReference path:(NSString *)path {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"/(.|[\\r\\n])*"](path);

  self = [super init];
  if (self) {
    _dCopyReference = dCopyReference;
    _path = path;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveCopyReferenceArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveCopyReferenceArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveCopyReferenceArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.dCopyReference hash];
  result = prime * result + [self.path hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveCopyReferenceArg:other];
}

- (BOOL)isEqualToSaveCopyReferenceArg:(DBFILESSaveCopyReferenceArg *)aSaveCopyReferenceArg {
  if (self == aSaveCopyReferenceArg) {
    return YES;
  }
  if (![self.dCopyReference isEqual:aSaveCopyReferenceArg.dCopyReference]) {
    return NO;
  }
  if (![self.path isEqual:aSaveCopyReferenceArg.path]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveCopyReferenceArgSerializer

+ (NSDictionary *)serialize:(DBFILESSaveCopyReferenceArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"copy_reference"] = valueObj.dCopyReference;
  jsonDict[@"path"] = valueObj.path;

  return jsonDict;
}

+ (DBFILESSaveCopyReferenceArg *)deserialize:(NSDictionary *)valueDict {
  NSString *dCopyReference = valueDict[@"copy_reference"];
  NSString *path = valueDict[@"path"];

  return [[DBFILESSaveCopyReferenceArg alloc] initWithDCopyReference:dCopyReference path:path];
}

@end

#import "DBFILESSaveCopyReferenceError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveCopyReferenceError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESWriteError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveCopyReferenceErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithInvalidCopyReference {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveCopyReferenceErrorInvalidCopyReference;
  }
  return self;
}

- (instancetype)initWithNoPermission {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveCopyReferenceErrorNoPermission;
  }
  return self;
}

- (instancetype)initWithNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveCopyReferenceErrorNotFound;
  }
  return self;
}

- (instancetype)initWithTooManyFiles {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveCopyReferenceErrorTooManyFiles;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveCopyReferenceErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESWriteError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSaveCopyReferenceErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESSaveCopyReferenceErrorPath;
}

- (BOOL)isInvalidCopyReference {
  return _tag == DBFILESSaveCopyReferenceErrorInvalidCopyReference;
}

- (BOOL)isNoPermission {
  return _tag == DBFILESSaveCopyReferenceErrorNoPermission;
}

- (BOOL)isNotFound {
  return _tag == DBFILESSaveCopyReferenceErrorNotFound;
}

- (BOOL)isTooManyFiles {
  return _tag == DBFILESSaveCopyReferenceErrorTooManyFiles;
}

- (BOOL)isOther {
  return _tag == DBFILESSaveCopyReferenceErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSaveCopyReferenceErrorPath:
    return @"DBFILESSaveCopyReferenceErrorPath";
  case DBFILESSaveCopyReferenceErrorInvalidCopyReference:
    return @"DBFILESSaveCopyReferenceErrorInvalidCopyReference";
  case DBFILESSaveCopyReferenceErrorNoPermission:
    return @"DBFILESSaveCopyReferenceErrorNoPermission";
  case DBFILESSaveCopyReferenceErrorNotFound:
    return @"DBFILESSaveCopyReferenceErrorNotFound";
  case DBFILESSaveCopyReferenceErrorTooManyFiles:
    return @"DBFILESSaveCopyReferenceErrorTooManyFiles";
  case DBFILESSaveCopyReferenceErrorOther:
    return @"DBFILESSaveCopyReferenceErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveCopyReferenceErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveCopyReferenceErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveCopyReferenceErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSaveCopyReferenceErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESSaveCopyReferenceErrorInvalidCopyReference:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveCopyReferenceErrorNoPermission:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveCopyReferenceErrorNotFound:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveCopyReferenceErrorTooManyFiles:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveCopyReferenceErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveCopyReferenceError:other];
}

- (BOOL)isEqualToSaveCopyReferenceError:(DBFILESSaveCopyReferenceError *)aSaveCopyReferenceError {
  if (self == aSaveCopyReferenceError) {
    return YES;
  }
  if (self.tag != aSaveCopyReferenceError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSaveCopyReferenceErrorPath:
    return [self.path isEqual:aSaveCopyReferenceError.path];
  case DBFILESSaveCopyReferenceErrorInvalidCopyReference:
    return [[self tagName] isEqual:[aSaveCopyReferenceError tagName]];
  case DBFILESSaveCopyReferenceErrorNoPermission:
    return [[self tagName] isEqual:[aSaveCopyReferenceError tagName]];
  case DBFILESSaveCopyReferenceErrorNotFound:
    return [[self tagName] isEqual:[aSaveCopyReferenceError tagName]];
  case DBFILESSaveCopyReferenceErrorTooManyFiles:
    return [[self tagName] isEqual:[aSaveCopyReferenceError tagName]];
  case DBFILESSaveCopyReferenceErrorOther:
    return [[self tagName] isEqual:[aSaveCopyReferenceError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveCopyReferenceErrorSerializer

+ (NSDictionary *)serialize:(DBFILESSaveCopyReferenceError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESWriteErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isInvalidCopyReference]) {
    jsonDict[@".tag"] = @"invalid_copy_reference";
  } else if ([valueObj isNoPermission]) {
    jsonDict[@".tag"] = @"no_permission";
  } else if ([valueObj isNotFound]) {
    jsonDict[@".tag"] = @"not_found";
  } else if ([valueObj isTooManyFiles]) {
    jsonDict[@".tag"] = @"too_many_files";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESSaveCopyReferenceError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESWriteError *path = [DBFILESWriteErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESSaveCopyReferenceError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"invalid_copy_reference"]) {
    return [[DBFILESSaveCopyReferenceError alloc] initWithInvalidCopyReference];
  } else if ([tag isEqualToString:@"no_permission"]) {
    return [[DBFILESSaveCopyReferenceError alloc] initWithNoPermission];
  } else if ([tag isEqualToString:@"not_found"]) {
    return [[DBFILESSaveCopyReferenceError alloc] initWithNotFound];
  } else if ([tag isEqualToString:@"too_many_files"]) {
    return [[DBFILESSaveCopyReferenceError alloc] initWithTooManyFiles];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESSaveCopyReferenceError alloc] initWithOther];
  } else {
    return [[DBFILESSaveCopyReferenceError alloc] initWithOther];
  }
}

@end

#import "DBFILESMetadata.h"
#import "DBFILESSaveCopyReferenceResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveCopyReferenceResult

#pragma mark - Constructors

- (instancetype)initWithMetadata:(DBFILESMetadata *)metadata {

  self = [super init];
  if (self) {
    _metadata = metadata;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveCopyReferenceResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveCopyReferenceResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveCopyReferenceResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.metadata hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveCopyReferenceResult:other];
}

- (BOOL)isEqualToSaveCopyReferenceResult:(DBFILESSaveCopyReferenceResult *)aSaveCopyReferenceResult {
  if (self == aSaveCopyReferenceResult) {
    return YES;
  }
  if (![self.metadata isEqual:aSaveCopyReferenceResult.metadata]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveCopyReferenceResultSerializer

+ (NSDictionary *)serialize:(DBFILESSaveCopyReferenceResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"metadata"] = [DBFILESMetadataSerializer serialize:valueObj.metadata];

  return jsonDict;
}

+ (DBFILESSaveCopyReferenceResult *)deserialize:(NSDictionary *)valueDict {
  DBFILESMetadata *metadata = [DBFILESMetadataSerializer deserialize:valueDict[@"metadata"]];

  return [[DBFILESSaveCopyReferenceResult alloc] initWithMetadata:metadata];
}

@end

#import "DBFILESSaveUrlArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveUrlArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path url:(NSString *)url {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"/(.|[\\r\\n])*"](path);

  self = [super init];
  if (self) {
    _path = path;
    _url = url;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveUrlArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveUrlArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveUrlArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.url hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveUrlArg:other];
}

- (BOOL)isEqualToSaveUrlArg:(DBFILESSaveUrlArg *)aSaveUrlArg {
  if (self == aSaveUrlArg) {
    return YES;
  }
  if (![self.path isEqual:aSaveUrlArg.path]) {
    return NO;
  }
  if (![self.url isEqual:aSaveUrlArg.url]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveUrlArgSerializer

+ (NSDictionary *)serialize:(DBFILESSaveUrlArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"url"] = valueObj.url;

  return jsonDict;
}

+ (DBFILESSaveUrlArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSString *url = valueDict[@"url"];

  return [[DBFILESSaveUrlArg alloc] initWithPath:path url:url];
}

@end

#import "DBFILESSaveUrlError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveUrlError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESWriteError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithDownloadFailed {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlErrorDownloadFailed;
  }
  return self;
}

- (instancetype)initWithInvalidUrl {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlErrorInvalidUrl;
  }
  return self;
}

- (instancetype)initWithNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlErrorNotFound;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESWriteError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSaveUrlErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESSaveUrlErrorPath;
}

- (BOOL)isDownloadFailed {
  return _tag == DBFILESSaveUrlErrorDownloadFailed;
}

- (BOOL)isInvalidUrl {
  return _tag == DBFILESSaveUrlErrorInvalidUrl;
}

- (BOOL)isNotFound {
  return _tag == DBFILESSaveUrlErrorNotFound;
}

- (BOOL)isOther {
  return _tag == DBFILESSaveUrlErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSaveUrlErrorPath:
    return @"DBFILESSaveUrlErrorPath";
  case DBFILESSaveUrlErrorDownloadFailed:
    return @"DBFILESSaveUrlErrorDownloadFailed";
  case DBFILESSaveUrlErrorInvalidUrl:
    return @"DBFILESSaveUrlErrorInvalidUrl";
  case DBFILESSaveUrlErrorNotFound:
    return @"DBFILESSaveUrlErrorNotFound";
  case DBFILESSaveUrlErrorOther:
    return @"DBFILESSaveUrlErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveUrlErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveUrlErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveUrlErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSaveUrlErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESSaveUrlErrorDownloadFailed:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveUrlErrorInvalidUrl:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveUrlErrorNotFound:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveUrlErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveUrlError:other];
}

- (BOOL)isEqualToSaveUrlError:(DBFILESSaveUrlError *)aSaveUrlError {
  if (self == aSaveUrlError) {
    return YES;
  }
  if (self.tag != aSaveUrlError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSaveUrlErrorPath:
    return [self.path isEqual:aSaveUrlError.path];
  case DBFILESSaveUrlErrorDownloadFailed:
    return [[self tagName] isEqual:[aSaveUrlError tagName]];
  case DBFILESSaveUrlErrorInvalidUrl:
    return [[self tagName] isEqual:[aSaveUrlError tagName]];
  case DBFILESSaveUrlErrorNotFound:
    return [[self tagName] isEqual:[aSaveUrlError tagName]];
  case DBFILESSaveUrlErrorOther:
    return [[self tagName] isEqual:[aSaveUrlError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveUrlErrorSerializer

+ (NSDictionary *)serialize:(DBFILESSaveUrlError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESWriteErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isDownloadFailed]) {
    jsonDict[@".tag"] = @"download_failed";
  } else if ([valueObj isInvalidUrl]) {
    jsonDict[@".tag"] = @"invalid_url";
  } else if ([valueObj isNotFound]) {
    jsonDict[@".tag"] = @"not_found";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESSaveUrlError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESWriteError *path = [DBFILESWriteErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESSaveUrlError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"download_failed"]) {
    return [[DBFILESSaveUrlError alloc] initWithDownloadFailed];
  } else if ([tag isEqualToString:@"invalid_url"]) {
    return [[DBFILESSaveUrlError alloc] initWithInvalidUrl];
  } else if ([tag isEqualToString:@"not_found"]) {
    return [[DBFILESSaveUrlError alloc] initWithNotFound];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESSaveUrlError alloc] initWithOther];
  } else {
    return [[DBFILESSaveUrlError alloc] initWithOther];
  }
}

@end

#import "DBASYNCPollResultBase.h"
#import "DBFILESFileMetadata.h"
#import "DBFILESSaveUrlError.h"
#import "DBFILESSaveUrlJobStatus.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveUrlJobStatus

@synthesize complete = _complete;
@synthesize failed = _failed;

#pragma mark - Constructors

- (instancetype)initWithInProgress {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlJobStatusInProgress;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESFileMetadata *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlJobStatusComplete;
    _complete = complete;
  }
  return self;
}

- (instancetype)initWithFailed:(DBFILESSaveUrlError *)failed {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlJobStatusFailed;
    _failed = failed;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESFileMetadata *)complete {
  if (![self isComplete]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSaveUrlJobStatusComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

- (DBFILESSaveUrlError *)failed {
  if (![self isFailed]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSaveUrlJobStatusFailed, but was %@.", [self tagName]];
  }
  return _failed;
}

#pragma mark - Tag state methods

- (BOOL)isInProgress {
  return _tag == DBFILESSaveUrlJobStatusInProgress;
}

- (BOOL)isComplete {
  return _tag == DBFILESSaveUrlJobStatusComplete;
}

- (BOOL)isFailed {
  return _tag == DBFILESSaveUrlJobStatusFailed;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSaveUrlJobStatusInProgress:
    return @"DBFILESSaveUrlJobStatusInProgress";
  case DBFILESSaveUrlJobStatusComplete:
    return @"DBFILESSaveUrlJobStatusComplete";
  case DBFILESSaveUrlJobStatusFailed:
    return @"DBFILESSaveUrlJobStatusFailed";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveUrlJobStatusSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveUrlJobStatusSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveUrlJobStatusSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSaveUrlJobStatusInProgress:
    result = prime * result + [[self tagName] hash];
  case DBFILESSaveUrlJobStatusComplete:
    result = prime * result + [self.complete hash];
  case DBFILESSaveUrlJobStatusFailed:
    result = prime * result + [self.failed hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveUrlJobStatus:other];
}

- (BOOL)isEqualToSaveUrlJobStatus:(DBFILESSaveUrlJobStatus *)aSaveUrlJobStatus {
  if (self == aSaveUrlJobStatus) {
    return YES;
  }
  if (self.tag != aSaveUrlJobStatus.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSaveUrlJobStatusInProgress:
    return [[self tagName] isEqual:[aSaveUrlJobStatus tagName]];
  case DBFILESSaveUrlJobStatusComplete:
    return [self.complete isEqual:aSaveUrlJobStatus.complete];
  case DBFILESSaveUrlJobStatusFailed:
    return [self.failed isEqual:aSaveUrlJobStatus.failed];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveUrlJobStatusSerializer

+ (NSDictionary *)serialize:(DBFILESSaveUrlJobStatus *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isInProgress]) {
    jsonDict[@".tag"] = @"in_progress";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESFileMetadataSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else if ([valueObj isFailed]) {
    jsonDict[@"failed"] = [[DBFILESSaveUrlErrorSerializer serialize:valueObj.failed] mutableCopy];
    jsonDict[@".tag"] = @"failed";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESSaveUrlJobStatus *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"in_progress"]) {
    return [[DBFILESSaveUrlJobStatus alloc] initWithInProgress];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESFileMetadata *complete = [DBFILESFileMetadataSerializer deserialize:valueDict];
    return [[DBFILESSaveUrlJobStatus alloc] initWithComplete:complete];
  } else if ([tag isEqualToString:@"failed"]) {
    DBFILESSaveUrlError *failed = [DBFILESSaveUrlErrorSerializer deserialize:valueDict[@"failed"]];
    return [[DBFILESSaveUrlJobStatus alloc] initWithFailed:failed];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBASYNCLaunchResultBase.h"
#import "DBFILESFileMetadata.h"
#import "DBFILESSaveUrlResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSaveUrlResult

@synthesize asyncJobId = _asyncJobId;
@synthesize complete = _complete;

#pragma mark - Constructors

- (instancetype)initWithAsyncJobId:(NSString *)asyncJobId {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlResultAsyncJobId;
    _asyncJobId = asyncJobId;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESFileMetadata *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESSaveUrlResultComplete;
    _complete = complete;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)asyncJobId {
  if (![self isAsyncJobId]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSaveUrlResultAsyncJobId, but was %@.", [self tagName]];
  }
  return _asyncJobId;
}

- (DBFILESFileMetadata *)complete {
  if (![self isComplete]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSaveUrlResultComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

#pragma mark - Tag state methods

- (BOOL)isAsyncJobId {
  return _tag == DBFILESSaveUrlResultAsyncJobId;
}

- (BOOL)isComplete {
  return _tag == DBFILESSaveUrlResultComplete;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSaveUrlResultAsyncJobId:
    return @"DBFILESSaveUrlResultAsyncJobId";
  case DBFILESSaveUrlResultComplete:
    return @"DBFILESSaveUrlResultComplete";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSaveUrlResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSaveUrlResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSaveUrlResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSaveUrlResultAsyncJobId:
    result = prime * result + [self.asyncJobId hash];
  case DBFILESSaveUrlResultComplete:
    result = prime * result + [self.complete hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSaveUrlResult:other];
}

- (BOOL)isEqualToSaveUrlResult:(DBFILESSaveUrlResult *)aSaveUrlResult {
  if (self == aSaveUrlResult) {
    return YES;
  }
  if (self.tag != aSaveUrlResult.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSaveUrlResultAsyncJobId:
    return [self.asyncJobId isEqual:aSaveUrlResult.asyncJobId];
  case DBFILESSaveUrlResultComplete:
    return [self.complete isEqual:aSaveUrlResult.complete];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSaveUrlResultSerializer

+ (NSDictionary *)serialize:(DBFILESSaveUrlResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isAsyncJobId]) {
    jsonDict[@"async_job_id"] = valueObj.asyncJobId;
    jsonDict[@".tag"] = @"async_job_id";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESFileMetadataSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESSaveUrlResult *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"async_job_id"]) {
    NSString *asyncJobId = valueDict[@"async_job_id"];
    return [[DBFILESSaveUrlResult alloc] initWithAsyncJobId:asyncJobId];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESFileMetadata *complete = [DBFILESFileMetadataSerializer deserialize:valueDict];
    return [[DBFILESSaveUrlResult alloc] initWithComplete:complete];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESSearchArg.h"
#import "DBFILESSearchMode.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSearchArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                       query:(NSString *)query
                       start:(NSNumber *)start
                  maxResults:(NSNumber *)maxResults
                        mode:(DBFILESSearchMode *)mode {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"(/(.|[\\r\\n])*)?|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators numericValidator:@(1) maxValue:@(1000)](maxResults ?: @(100));

  self = [super init];
  if (self) {
    _path = path;
    _query = query;
    _start = start ?: @(0);
    _maxResults = maxResults ?: @(100);
    _mode = mode ?: [[DBFILESSearchMode alloc] initWithFilename];
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path query:(NSString *)query {
  return [self initWithPath:path query:query start:nil maxResults:nil mode:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSearchArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSearchArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSearchArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.query hash];
  result = prime * result + [self.start hash];
  result = prime * result + [self.maxResults hash];
  result = prime * result + [self.mode hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSearchArg:other];
}

- (BOOL)isEqualToSearchArg:(DBFILESSearchArg *)aSearchArg {
  if (self == aSearchArg) {
    return YES;
  }
  if (![self.path isEqual:aSearchArg.path]) {
    return NO;
  }
  if (![self.query isEqual:aSearchArg.query]) {
    return NO;
  }
  if (![self.start isEqual:aSearchArg.start]) {
    return NO;
  }
  if (![self.maxResults isEqual:aSearchArg.maxResults]) {
    return NO;
  }
  if (![self.mode isEqual:aSearchArg.mode]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSearchArgSerializer

+ (NSDictionary *)serialize:(DBFILESSearchArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"query"] = valueObj.query;
  jsonDict[@"start"] = valueObj.start;
  jsonDict[@"max_results"] = valueObj.maxResults;
  jsonDict[@"mode"] = [DBFILESSearchModeSerializer serialize:valueObj.mode];

  return jsonDict;
}

+ (DBFILESSearchArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSString *query = valueDict[@"query"];
  NSNumber *start = valueDict[@"start"] ?: @(0);
  NSNumber *maxResults = valueDict[@"max_results"] ?: @(100);
  DBFILESSearchMode *mode = valueDict[@"mode"] ? [DBFILESSearchModeSerializer deserialize:valueDict[@"mode"]]
                                               : [[DBFILESSearchMode alloc] initWithFilename];

  return [[DBFILESSearchArg alloc] initWithPath:path query:query start:start maxResults:maxResults mode:mode];
}

@end

#import "DBFILESLookupError.h"
#import "DBFILESSearchError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSearchError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESSearchErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESSearchErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESSearchErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSearchErrorPath:
    return @"DBFILESSearchErrorPath";
  case DBFILESSearchErrorOther:
    return @"DBFILESSearchErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSearchErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSearchErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSearchErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSearchErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESSearchErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSearchError:other];
}

- (BOOL)isEqualToSearchError:(DBFILESSearchError *)aSearchError {
  if (self == aSearchError) {
    return YES;
  }
  if (self.tag != aSearchError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSearchErrorPath:
    return [self.path isEqual:aSearchError.path];
  case DBFILESSearchErrorOther:
    return [[self tagName] isEqual:[aSearchError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSearchErrorSerializer

+ (NSDictionary *)serialize:(DBFILESSearchError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESSearchError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESSearchError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESSearchError alloc] initWithOther];
  } else {
    return [[DBFILESSearchError alloc] initWithOther];
  }
}

@end

#import "DBFILESMetadata.h"
#import "DBFILESSearchMatch.h"
#import "DBFILESSearchMatchType.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSearchMatch

#pragma mark - Constructors

- (instancetype)initWithMatchType:(DBFILESSearchMatchType *)matchType metadata:(DBFILESMetadata *)metadata {

  self = [super init];
  if (self) {
    _matchType = matchType;
    _metadata = metadata;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSearchMatchSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSearchMatchSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSearchMatchSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.matchType hash];
  result = prime * result + [self.metadata hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSearchMatch:other];
}

- (BOOL)isEqualToSearchMatch:(DBFILESSearchMatch *)aSearchMatch {
  if (self == aSearchMatch) {
    return YES;
  }
  if (![self.matchType isEqual:aSearchMatch.matchType]) {
    return NO;
  }
  if (![self.metadata isEqual:aSearchMatch.metadata]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSearchMatchSerializer

+ (NSDictionary *)serialize:(DBFILESSearchMatch *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"match_type"] = [DBFILESSearchMatchTypeSerializer serialize:valueObj.matchType];
  jsonDict[@"metadata"] = [DBFILESMetadataSerializer serialize:valueObj.metadata];

  return jsonDict;
}

+ (DBFILESSearchMatch *)deserialize:(NSDictionary *)valueDict {
  DBFILESSearchMatchType *matchType = [DBFILESSearchMatchTypeSerializer deserialize:valueDict[@"match_type"]];
  DBFILESMetadata *metadata = [DBFILESMetadataSerializer deserialize:valueDict[@"metadata"]];

  return [[DBFILESSearchMatch alloc] initWithMatchType:matchType metadata:metadata];
}

@end

#import "DBFILESSearchMatchType.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSearchMatchType

#pragma mark - Constructors

- (instancetype)initWithFilename {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchMatchTypeFilename;
  }
  return self;
}

- (instancetype)initWithContent {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchMatchTypeContent;
  }
  return self;
}

- (instancetype)initWithBoth {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchMatchTypeBoth;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isFilename {
  return _tag == DBFILESSearchMatchTypeFilename;
}

- (BOOL)isContent {
  return _tag == DBFILESSearchMatchTypeContent;
}

- (BOOL)isBoth {
  return _tag == DBFILESSearchMatchTypeBoth;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSearchMatchTypeFilename:
    return @"DBFILESSearchMatchTypeFilename";
  case DBFILESSearchMatchTypeContent:
    return @"DBFILESSearchMatchTypeContent";
  case DBFILESSearchMatchTypeBoth:
    return @"DBFILESSearchMatchTypeBoth";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSearchMatchTypeSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSearchMatchTypeSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSearchMatchTypeSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSearchMatchTypeFilename:
    result = prime * result + [[self tagName] hash];
  case DBFILESSearchMatchTypeContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESSearchMatchTypeBoth:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSearchMatchType:other];
}

- (BOOL)isEqualToSearchMatchType:(DBFILESSearchMatchType *)aSearchMatchType {
  if (self == aSearchMatchType) {
    return YES;
  }
  if (self.tag != aSearchMatchType.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSearchMatchTypeFilename:
    return [[self tagName] isEqual:[aSearchMatchType tagName]];
  case DBFILESSearchMatchTypeContent:
    return [[self tagName] isEqual:[aSearchMatchType tagName]];
  case DBFILESSearchMatchTypeBoth:
    return [[self tagName] isEqual:[aSearchMatchType tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSearchMatchTypeSerializer

+ (NSDictionary *)serialize:(DBFILESSearchMatchType *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isFilename]) {
    jsonDict[@".tag"] = @"filename";
  } else if ([valueObj isContent]) {
    jsonDict[@".tag"] = @"content";
  } else if ([valueObj isBoth]) {
    jsonDict[@".tag"] = @"both";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESSearchMatchType *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"filename"]) {
    return [[DBFILESSearchMatchType alloc] initWithFilename];
  } else if ([tag isEqualToString:@"content"]) {
    return [[DBFILESSearchMatchType alloc] initWithContent];
  } else if ([tag isEqualToString:@"both"]) {
    return [[DBFILESSearchMatchType alloc] initWithBoth];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESSearchMode.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSearchMode

#pragma mark - Constructors

- (instancetype)initWithFilename {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchModeFilename;
  }
  return self;
}

- (instancetype)initWithFilenameAndContent {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchModeFilenameAndContent;
  }
  return self;
}

- (instancetype)initWithDeletedFilename {
  self = [super init];
  if (self) {
    _tag = DBFILESSearchModeDeletedFilename;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isFilename {
  return _tag == DBFILESSearchModeFilename;
}

- (BOOL)isFilenameAndContent {
  return _tag == DBFILESSearchModeFilenameAndContent;
}

- (BOOL)isDeletedFilename {
  return _tag == DBFILESSearchModeDeletedFilename;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESSearchModeFilename:
    return @"DBFILESSearchModeFilename";
  case DBFILESSearchModeFilenameAndContent:
    return @"DBFILESSearchModeFilenameAndContent";
  case DBFILESSearchModeDeletedFilename:
    return @"DBFILESSearchModeDeletedFilename";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSearchModeSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSearchModeSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSearchModeSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESSearchModeFilename:
    result = prime * result + [[self tagName] hash];
  case DBFILESSearchModeFilenameAndContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESSearchModeDeletedFilename:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSearchMode:other];
}

- (BOOL)isEqualToSearchMode:(DBFILESSearchMode *)aSearchMode {
  if (self == aSearchMode) {
    return YES;
  }
  if (self.tag != aSearchMode.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESSearchModeFilename:
    return [[self tagName] isEqual:[aSearchMode tagName]];
  case DBFILESSearchModeFilenameAndContent:
    return [[self tagName] isEqual:[aSearchMode tagName]];
  case DBFILESSearchModeDeletedFilename:
    return [[self tagName] isEqual:[aSearchMode tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSearchModeSerializer

+ (NSDictionary *)serialize:(DBFILESSearchMode *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isFilename]) {
    jsonDict[@".tag"] = @"filename";
  } else if ([valueObj isFilenameAndContent]) {
    jsonDict[@".tag"] = @"filename_and_content";
  } else if ([valueObj isDeletedFilename]) {
    jsonDict[@".tag"] = @"deleted_filename";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESSearchMode *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"filename"]) {
    return [[DBFILESSearchMode alloc] initWithFilename];
  } else if ([tag isEqualToString:@"filename_and_content"]) {
    return [[DBFILESSearchMode alloc] initWithFilenameAndContent];
  } else if ([tag isEqualToString:@"deleted_filename"]) {
    return [[DBFILESSearchMode alloc] initWithDeletedFilename];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESSearchMatch.h"
#import "DBFILESSearchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESSearchResult

#pragma mark - Constructors

- (instancetype)initWithMatches:(NSArray<DBFILESSearchMatch *> *)matches more:(NSNumber *)more start:(NSNumber *)start {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](matches);

  self = [super init];
  if (self) {
    _matches = matches;
    _more = more;
    _start = start;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESSearchResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESSearchResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESSearchResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.matches hash];
  result = prime * result + [self.more hash];
  result = prime * result + [self.start hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToSearchResult:other];
}

- (BOOL)isEqualToSearchResult:(DBFILESSearchResult *)aSearchResult {
  if (self == aSearchResult) {
    return YES;
  }
  if (![self.matches isEqual:aSearchResult.matches]) {
    return NO;
  }
  if (![self.more isEqual:aSearchResult.more]) {
    return NO;
  }
  if (![self.start isEqual:aSearchResult.start]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESSearchResultSerializer

+ (NSDictionary *)serialize:(DBFILESSearchResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"matches"] = [DBArraySerializer serialize:valueObj.matches
                                            withBlock:^id(id elem0) {
                                              return [DBFILESSearchMatchSerializer serialize:elem0];
                                            }];
  jsonDict[@"more"] = valueObj.more;
  jsonDict[@"start"] = valueObj.start;

  return jsonDict;
}

+ (DBFILESSearchResult *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESSearchMatch *> *matches =
      [DBArraySerializer deserialize:valueDict[@"matches"]
                           withBlock:^id(id elem0) {
                             return [DBFILESSearchMatchSerializer deserialize:elem0];
                           }];
  NSNumber *more = valueDict[@"more"];
  NSNumber *start = valueDict[@"start"];

  return [[DBFILESSearchResult alloc] initWithMatches:matches more:more start:start];
}

@end

#import "DBFILESThumbnailArg.h"
#import "DBFILESThumbnailFormat.h"
#import "DBFILESThumbnailSize.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESThumbnailArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
                      format:(DBFILESThumbnailFormat *)format
                        size:(DBFILESThumbnailSize *)size {
  [DBStoneValidators stringValidator:nil maxLength:nil
                             pattern:@"(/(.|[\\r\\n])*|id:.*)|(rev:[0-9a-f]{9,})|(ns:[0-9]+(/.*)?)"](path);

  self = [super init];
  if (self) {
    _path = path;
    _format = format ?: [[DBFILESThumbnailFormat alloc] initWithJpeg];
    _size = size ?: [[DBFILESThumbnailSize alloc] initWithW64h64];
  }
  return self;
}

- (instancetype)initWithPath:(NSString *)path {
  return [self initWithPath:path format:nil size:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESThumbnailArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESThumbnailArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESThumbnailArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.format hash];
  result = prime * result + [self.size hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToThumbnailArg:other];
}

- (BOOL)isEqualToThumbnailArg:(DBFILESThumbnailArg *)aThumbnailArg {
  if (self == aThumbnailArg) {
    return YES;
  }
  if (![self.path isEqual:aThumbnailArg.path]) {
    return NO;
  }
  if (![self.format isEqual:aThumbnailArg.format]) {
    return NO;
  }
  if (![self.size isEqual:aThumbnailArg.size]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESThumbnailArgSerializer

+ (NSDictionary *)serialize:(DBFILESThumbnailArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"format"] = [DBFILESThumbnailFormatSerializer serialize:valueObj.format];
  jsonDict[@"size"] = [DBFILESThumbnailSizeSerializer serialize:valueObj.size];

  return jsonDict;
}

+ (DBFILESThumbnailArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  DBFILESThumbnailFormat *format = valueDict[@"format"]
                                       ? [DBFILESThumbnailFormatSerializer deserialize:valueDict[@"format"]]
                                       : [[DBFILESThumbnailFormat alloc] initWithJpeg];
  DBFILESThumbnailSize *size = valueDict[@"size"] ? [DBFILESThumbnailSizeSerializer deserialize:valueDict[@"size"]]
                                                  : [[DBFILESThumbnailSize alloc] initWithW64h64];

  return [[DBFILESThumbnailArg alloc] initWithPath:path format:format size:size];
}

@end

#import "DBFILESLookupError.h"
#import "DBFILESThumbnailError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESThumbnailError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithUnsupportedExtension {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailErrorUnsupportedExtension;
  }
  return self;
}

- (instancetype)initWithUnsupportedImage {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailErrorUnsupportedImage;
  }
  return self;
}

- (instancetype)initWithConversionError {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailErrorConversionError;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESThumbnailErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESThumbnailErrorPath;
}

- (BOOL)isUnsupportedExtension {
  return _tag == DBFILESThumbnailErrorUnsupportedExtension;
}

- (BOOL)isUnsupportedImage {
  return _tag == DBFILESThumbnailErrorUnsupportedImage;
}

- (BOOL)isConversionError {
  return _tag == DBFILESThumbnailErrorConversionError;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESThumbnailErrorPath:
    return @"DBFILESThumbnailErrorPath";
  case DBFILESThumbnailErrorUnsupportedExtension:
    return @"DBFILESThumbnailErrorUnsupportedExtension";
  case DBFILESThumbnailErrorUnsupportedImage:
    return @"DBFILESThumbnailErrorUnsupportedImage";
  case DBFILESThumbnailErrorConversionError:
    return @"DBFILESThumbnailErrorConversionError";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESThumbnailErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESThumbnailErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESThumbnailErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESThumbnailErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESThumbnailErrorUnsupportedExtension:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailErrorUnsupportedImage:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailErrorConversionError:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToThumbnailError:other];
}

- (BOOL)isEqualToThumbnailError:(DBFILESThumbnailError *)aThumbnailError {
  if (self == aThumbnailError) {
    return YES;
  }
  if (self.tag != aThumbnailError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESThumbnailErrorPath:
    return [self.path isEqual:aThumbnailError.path];
  case DBFILESThumbnailErrorUnsupportedExtension:
    return [[self tagName] isEqual:[aThumbnailError tagName]];
  case DBFILESThumbnailErrorUnsupportedImage:
    return [[self tagName] isEqual:[aThumbnailError tagName]];
  case DBFILESThumbnailErrorConversionError:
    return [[self tagName] isEqual:[aThumbnailError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESThumbnailErrorSerializer

+ (NSDictionary *)serialize:(DBFILESThumbnailError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isUnsupportedExtension]) {
    jsonDict[@".tag"] = @"unsupported_extension";
  } else if ([valueObj isUnsupportedImage]) {
    jsonDict[@".tag"] = @"unsupported_image";
  } else if ([valueObj isConversionError]) {
    jsonDict[@".tag"] = @"conversion_error";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESThumbnailError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESThumbnailError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"unsupported_extension"]) {
    return [[DBFILESThumbnailError alloc] initWithUnsupportedExtension];
  } else if ([tag isEqualToString:@"unsupported_image"]) {
    return [[DBFILESThumbnailError alloc] initWithUnsupportedImage];
  } else if ([tag isEqualToString:@"conversion_error"]) {
    return [[DBFILESThumbnailError alloc] initWithConversionError];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESThumbnailFormat.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESThumbnailFormat

#pragma mark - Constructors

- (instancetype)initWithJpeg {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailFormatJpeg;
  }
  return self;
}

- (instancetype)initWithPng {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailFormatPng;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isJpeg {
  return _tag == DBFILESThumbnailFormatJpeg;
}

- (BOOL)isPng {
  return _tag == DBFILESThumbnailFormatPng;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESThumbnailFormatJpeg:
    return @"DBFILESThumbnailFormatJpeg";
  case DBFILESThumbnailFormatPng:
    return @"DBFILESThumbnailFormatPng";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESThumbnailFormatSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESThumbnailFormatSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESThumbnailFormatSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESThumbnailFormatJpeg:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailFormatPng:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToThumbnailFormat:other];
}

- (BOOL)isEqualToThumbnailFormat:(DBFILESThumbnailFormat *)aThumbnailFormat {
  if (self == aThumbnailFormat) {
    return YES;
  }
  if (self.tag != aThumbnailFormat.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESThumbnailFormatJpeg:
    return [[self tagName] isEqual:[aThumbnailFormat tagName]];
  case DBFILESThumbnailFormatPng:
    return [[self tagName] isEqual:[aThumbnailFormat tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESThumbnailFormatSerializer

+ (NSDictionary *)serialize:(DBFILESThumbnailFormat *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isJpeg]) {
    jsonDict[@".tag"] = @"jpeg";
  } else if ([valueObj isPng]) {
    jsonDict[@".tag"] = @"png";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESThumbnailFormat *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"jpeg"]) {
    return [[DBFILESThumbnailFormat alloc] initWithJpeg];
  } else if ([tag isEqualToString:@"png"]) {
    return [[DBFILESThumbnailFormat alloc] initWithPng];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESThumbnailSize.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESThumbnailSize

#pragma mark - Constructors

- (instancetype)initWithW32h32 {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailSizeW32h32;
  }
  return self;
}

- (instancetype)initWithW64h64 {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailSizeW64h64;
  }
  return self;
}

- (instancetype)initWithW128h128 {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailSizeW128h128;
  }
  return self;
}

- (instancetype)initWithW640h480 {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailSizeW640h480;
  }
  return self;
}

- (instancetype)initWithW1024h768 {
  self = [super init];
  if (self) {
    _tag = DBFILESThumbnailSizeW1024h768;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isW32h32 {
  return _tag == DBFILESThumbnailSizeW32h32;
}

- (BOOL)isW64h64 {
  return _tag == DBFILESThumbnailSizeW64h64;
}

- (BOOL)isW128h128 {
  return _tag == DBFILESThumbnailSizeW128h128;
}

- (BOOL)isW640h480 {
  return _tag == DBFILESThumbnailSizeW640h480;
}

- (BOOL)isW1024h768 {
  return _tag == DBFILESThumbnailSizeW1024h768;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESThumbnailSizeW32h32:
    return @"DBFILESThumbnailSizeW32h32";
  case DBFILESThumbnailSizeW64h64:
    return @"DBFILESThumbnailSizeW64h64";
  case DBFILESThumbnailSizeW128h128:
    return @"DBFILESThumbnailSizeW128h128";
  case DBFILESThumbnailSizeW640h480:
    return @"DBFILESThumbnailSizeW640h480";
  case DBFILESThumbnailSizeW1024h768:
    return @"DBFILESThumbnailSizeW1024h768";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESThumbnailSizeSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESThumbnailSizeSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESThumbnailSizeSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESThumbnailSizeW32h32:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailSizeW64h64:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailSizeW128h128:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailSizeW640h480:
    result = prime * result + [[self tagName] hash];
  case DBFILESThumbnailSizeW1024h768:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToThumbnailSize:other];
}

- (BOOL)isEqualToThumbnailSize:(DBFILESThumbnailSize *)aThumbnailSize {
  if (self == aThumbnailSize) {
    return YES;
  }
  if (self.tag != aThumbnailSize.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESThumbnailSizeW32h32:
    return [[self tagName] isEqual:[aThumbnailSize tagName]];
  case DBFILESThumbnailSizeW64h64:
    return [[self tagName] isEqual:[aThumbnailSize tagName]];
  case DBFILESThumbnailSizeW128h128:
    return [[self tagName] isEqual:[aThumbnailSize tagName]];
  case DBFILESThumbnailSizeW640h480:
    return [[self tagName] isEqual:[aThumbnailSize tagName]];
  case DBFILESThumbnailSizeW1024h768:
    return [[self tagName] isEqual:[aThumbnailSize tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESThumbnailSizeSerializer

+ (NSDictionary *)serialize:(DBFILESThumbnailSize *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isW32h32]) {
    jsonDict[@".tag"] = @"w32h32";
  } else if ([valueObj isW64h64]) {
    jsonDict[@".tag"] = @"w64h64";
  } else if ([valueObj isW128h128]) {
    jsonDict[@".tag"] = @"w128h128";
  } else if ([valueObj isW640h480]) {
    jsonDict[@".tag"] = @"w640h480";
  } else if ([valueObj isW1024h768]) {
    jsonDict[@".tag"] = @"w1024h768";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESThumbnailSize *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"w32h32"]) {
    return [[DBFILESThumbnailSize alloc] initWithW32h32];
  } else if ([tag isEqualToString:@"w64h64"]) {
    return [[DBFILESThumbnailSize alloc] initWithW64h64];
  } else if ([tag isEqualToString:@"w128h128"]) {
    return [[DBFILESThumbnailSize alloc] initWithW128h128];
  } else if ([tag isEqualToString:@"w640h480"]) {
    return [[DBFILESThumbnailSize alloc] initWithW640h480];
  } else if ([tag isEqualToString:@"w1024h768"]) {
    return [[DBFILESThumbnailSize alloc] initWithW1024h768];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESInvalidPropertyGroupError.h"
#import "DBFILESLookUpPropertiesError.h"
#import "DBFILESLookupError.h"
#import "DBFILESUpdatePropertiesError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUpdatePropertiesError

@synthesize templateNotFound = _templateNotFound;
@synthesize path = _path;
@synthesize propertyGroupLookup = _propertyGroupLookup;

#pragma mark - Constructors

- (instancetype)initWithTemplateNotFound:(NSString *)templateNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorTemplateNotFound;
    _templateNotFound = templateNotFound;
  }
  return self;
}

- (instancetype)initWithRestrictedContent {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorRestrictedContent;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorOther;
  }
  return self;
}

- (instancetype)initWithPath:(DBFILESLookupError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithPropertyFieldTooLarge {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorPropertyFieldTooLarge;
  }
  return self;
}

- (instancetype)initWithDoesNotFitTemplate {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorDoesNotFitTemplate;
  }
  return self;
}

- (instancetype)initWithPropertyGroupLookup:(DBFILESLookUpPropertiesError *)propertyGroupLookup {
  self = [super init];
  if (self) {
    _tag = DBFILESUpdatePropertiesErrorPropertyGroupLookup;
    _propertyGroupLookup = propertyGroupLookup;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)templateNotFound {
  if (![self isTemplateNotFound]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUpdatePropertiesErrorTemplateNotFound, but was %@.", [self tagName]];
  }
  return _templateNotFound;
}

- (DBFILESLookupError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESUpdatePropertiesErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

- (DBFILESLookUpPropertiesError *)propertyGroupLookup {
  if (![self isPropertyGroupLookup]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUpdatePropertiesErrorPropertyGroupLookup, but was %@.", [self tagName]];
  }
  return _propertyGroupLookup;
}

#pragma mark - Tag state methods

- (BOOL)isTemplateNotFound {
  return _tag == DBFILESUpdatePropertiesErrorTemplateNotFound;
}

- (BOOL)isRestrictedContent {
  return _tag == DBFILESUpdatePropertiesErrorRestrictedContent;
}

- (BOOL)isOther {
  return _tag == DBFILESUpdatePropertiesErrorOther;
}

- (BOOL)isPath {
  return _tag == DBFILESUpdatePropertiesErrorPath;
}

- (BOOL)isPropertyFieldTooLarge {
  return _tag == DBFILESUpdatePropertiesErrorPropertyFieldTooLarge;
}

- (BOOL)isDoesNotFitTemplate {
  return _tag == DBFILESUpdatePropertiesErrorDoesNotFitTemplate;
}

- (BOOL)isPropertyGroupLookup {
  return _tag == DBFILESUpdatePropertiesErrorPropertyGroupLookup;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUpdatePropertiesErrorTemplateNotFound:
    return @"DBFILESUpdatePropertiesErrorTemplateNotFound";
  case DBFILESUpdatePropertiesErrorRestrictedContent:
    return @"DBFILESUpdatePropertiesErrorRestrictedContent";
  case DBFILESUpdatePropertiesErrorOther:
    return @"DBFILESUpdatePropertiesErrorOther";
  case DBFILESUpdatePropertiesErrorPath:
    return @"DBFILESUpdatePropertiesErrorPath";
  case DBFILESUpdatePropertiesErrorPropertyFieldTooLarge:
    return @"DBFILESUpdatePropertiesErrorPropertyFieldTooLarge";
  case DBFILESUpdatePropertiesErrorDoesNotFitTemplate:
    return @"DBFILESUpdatePropertiesErrorDoesNotFitTemplate";
  case DBFILESUpdatePropertiesErrorPropertyGroupLookup:
    return @"DBFILESUpdatePropertiesErrorPropertyGroupLookup";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUpdatePropertiesErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUpdatePropertiesErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUpdatePropertiesErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUpdatePropertiesErrorTemplateNotFound:
    result = prime * result + [self.templateNotFound hash];
  case DBFILESUpdatePropertiesErrorRestrictedContent:
    result = prime * result + [[self tagName] hash];
  case DBFILESUpdatePropertiesErrorOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESUpdatePropertiesErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESUpdatePropertiesErrorPropertyFieldTooLarge:
    result = prime * result + [[self tagName] hash];
  case DBFILESUpdatePropertiesErrorDoesNotFitTemplate:
    result = prime * result + [[self tagName] hash];
  case DBFILESUpdatePropertiesErrorPropertyGroupLookup:
    result = prime * result + [self.propertyGroupLookup hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUpdatePropertiesError:other];
}

- (BOOL)isEqualToUpdatePropertiesError:(DBFILESUpdatePropertiesError *)anUpdatePropertiesError {
  if (self == anUpdatePropertiesError) {
    return YES;
  }
  if (self.tag != anUpdatePropertiesError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUpdatePropertiesErrorTemplateNotFound:
    return [self.templateNotFound isEqual:anUpdatePropertiesError.templateNotFound];
  case DBFILESUpdatePropertiesErrorRestrictedContent:
    return [[self tagName] isEqual:[anUpdatePropertiesError tagName]];
  case DBFILESUpdatePropertiesErrorOther:
    return [[self tagName] isEqual:[anUpdatePropertiesError tagName]];
  case DBFILESUpdatePropertiesErrorPath:
    return [self.path isEqual:anUpdatePropertiesError.path];
  case DBFILESUpdatePropertiesErrorPropertyFieldTooLarge:
    return [[self tagName] isEqual:[anUpdatePropertiesError tagName]];
  case DBFILESUpdatePropertiesErrorDoesNotFitTemplate:
    return [[self tagName] isEqual:[anUpdatePropertiesError tagName]];
  case DBFILESUpdatePropertiesErrorPropertyGroupLookup:
    return [self.propertyGroupLookup isEqual:anUpdatePropertiesError.propertyGroupLookup];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUpdatePropertiesErrorSerializer

+ (NSDictionary *)serialize:(DBFILESUpdatePropertiesError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isTemplateNotFound]) {
    jsonDict[@"template_not_found"] = valueObj.templateNotFound;
    jsonDict[@".tag"] = @"template_not_found";
  } else if ([valueObj isRestrictedContent]) {
    jsonDict[@".tag"] = @"restricted_content";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESLookupErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isPropertyFieldTooLarge]) {
    jsonDict[@".tag"] = @"property_field_too_large";
  } else if ([valueObj isDoesNotFitTemplate]) {
    jsonDict[@".tag"] = @"does_not_fit_template";
  } else if ([valueObj isPropertyGroupLookup]) {
    jsonDict[@"property_group_lookup"] =
        [[DBFILESLookUpPropertiesErrorSerializer serialize:valueObj.propertyGroupLookup] mutableCopy];
    jsonDict[@".tag"] = @"property_group_lookup";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESUpdatePropertiesError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"template_not_found"]) {
    NSString *templateNotFound = valueDict[@"template_not_found"];
    return [[DBFILESUpdatePropertiesError alloc] initWithTemplateNotFound:templateNotFound];
  } else if ([tag isEqualToString:@"restricted_content"]) {
    return [[DBFILESUpdatePropertiesError alloc] initWithRestrictedContent];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESUpdatePropertiesError alloc] initWithOther];
  } else if ([tag isEqualToString:@"path"]) {
    DBFILESLookupError *path = [DBFILESLookupErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESUpdatePropertiesError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"property_field_too_large"]) {
    return [[DBFILESUpdatePropertiesError alloc] initWithPropertyFieldTooLarge];
  } else if ([tag isEqualToString:@"does_not_fit_template"]) {
    return [[DBFILESUpdatePropertiesError alloc] initWithDoesNotFitTemplate];
  } else if ([tag isEqualToString:@"property_group_lookup"]) {
    DBFILESLookUpPropertiesError *propertyGroupLookup =
        [DBFILESLookUpPropertiesErrorSerializer deserialize:valueDict[@"property_group_lookup"]];
    return [[DBFILESUpdatePropertiesError alloc] initWithPropertyGroupLookup:propertyGroupLookup];
  } else {
    return [[DBFILESUpdatePropertiesError alloc] initWithOther];
  }
}

@end

#import "DBFILESPropertyGroupUpdate.h"
#import "DBFILESUpdatePropertyGroupArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUpdatePropertyGroupArg

#pragma mark - Constructors

- (instancetype)initWithPath:(NSString *)path
        updatePropertyGroups:(NSArray<DBFILESPropertyGroupUpdate *> *)updatePropertyGroups {
  [DBStoneValidators stringValidator:nil maxLength:nil pattern:@"/(.|[\\r\\n])*|id:.*|(ns:[0-9]+(/.*)?)"](path);
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](updatePropertyGroups);

  self = [super init];
  if (self) {
    _path = path;
    _updatePropertyGroups = updatePropertyGroups;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUpdatePropertyGroupArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUpdatePropertyGroupArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUpdatePropertyGroupArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.path hash];
  result = prime * result + [self.updatePropertyGroups hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUpdatePropertyGroupArg:other];
}

- (BOOL)isEqualToUpdatePropertyGroupArg:(DBFILESUpdatePropertyGroupArg *)anUpdatePropertyGroupArg {
  if (self == anUpdatePropertyGroupArg) {
    return YES;
  }
  if (![self.path isEqual:anUpdatePropertyGroupArg.path]) {
    return NO;
  }
  if (![self.updatePropertyGroups isEqual:anUpdatePropertyGroupArg.updatePropertyGroups]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUpdatePropertyGroupArgSerializer

+ (NSDictionary *)serialize:(DBFILESUpdatePropertyGroupArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"path"] = valueObj.path;
  jsonDict[@"update_property_groups"] =
      [DBArraySerializer serialize:valueObj.updatePropertyGroups
                         withBlock:^id(id elem0) {
                           return [DBFILESPropertyGroupUpdateSerializer serialize:elem0];
                         }];

  return jsonDict;
}

+ (DBFILESUpdatePropertyGroupArg *)deserialize:(NSDictionary *)valueDict {
  NSString *path = valueDict[@"path"];
  NSArray<DBFILESPropertyGroupUpdate *> *updatePropertyGroups =
      [DBArraySerializer deserialize:valueDict[@"update_property_groups"]
                           withBlock:^id(id elem0) {
                             return [DBFILESPropertyGroupUpdateSerializer deserialize:elem0];
                           }];

  return [[DBFILESUpdatePropertyGroupArg alloc] initWithPath:path updatePropertyGroups:updatePropertyGroups];
}

@end

#import "DBFILESUploadError.h"
#import "DBFILESUploadWriteFailed.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadError

@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESUploadWriteFailed *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESUploadWriteFailed *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESUploadErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESUploadErrorPath;
}

- (BOOL)isOther {
  return _tag == DBFILESUploadErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadErrorPath:
    return @"DBFILESUploadErrorPath";
  case DBFILESUploadErrorOther:
    return @"DBFILESUploadErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESUploadErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadError:other];
}

- (BOOL)isEqualToUploadError:(DBFILESUploadError *)anUploadError {
  if (self == anUploadError) {
    return YES;
  }
  if (self.tag != anUploadError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadErrorPath:
    return [self.path isEqual:anUploadError.path];
  case DBFILESUploadErrorOther:
    return [[self tagName] isEqual:[anUploadError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadErrorSerializer

+ (NSDictionary *)serialize:(DBFILESUploadError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESUploadWriteFailedSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESUploadError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESUploadWriteFailed *path = [DBFILESUploadWriteFailedSerializer deserialize:valueDict];
    return [[DBFILESUploadError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESUploadError alloc] initWithOther];
  } else {
    return [[DBFILESUploadError alloc] initWithOther];
  }
}

@end

#import "DBFILESInvalidPropertyGroupError.h"
#import "DBFILESUploadError.h"
#import "DBFILESUploadErrorWithProperties.h"
#import "DBFILESUploadWriteFailed.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadErrorWithProperties

@synthesize path = _path;
@synthesize propertiesError = _propertiesError;

#pragma mark - Constructors

- (instancetype)initWithPath:(DBFILESUploadWriteFailed *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadErrorWithPropertiesPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadErrorWithPropertiesOther;
  }
  return self;
}

- (instancetype)initWithPropertiesError:(DBFILESInvalidPropertyGroupError *)propertiesError {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadErrorWithPropertiesPropertiesError;
    _propertiesError = propertiesError;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESUploadWriteFailed *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESUploadErrorWithPropertiesPath, but was %@.", [self tagName]];
  }
  return _path;
}

- (DBFILESInvalidPropertyGroupError *)propertiesError {
  if (![self isPropertiesError]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadErrorWithPropertiesPropertiesError, but was %@.", [self tagName]];
  }
  return _propertiesError;
}

#pragma mark - Tag state methods

- (BOOL)isPath {
  return _tag == DBFILESUploadErrorWithPropertiesPath;
}

- (BOOL)isOther {
  return _tag == DBFILESUploadErrorWithPropertiesOther;
}

- (BOOL)isPropertiesError {
  return _tag == DBFILESUploadErrorWithPropertiesPropertiesError;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadErrorWithPropertiesPath:
    return @"DBFILESUploadErrorWithPropertiesPath";
  case DBFILESUploadErrorWithPropertiesOther:
    return @"DBFILESUploadErrorWithPropertiesOther";
  case DBFILESUploadErrorWithPropertiesPropertiesError:
    return @"DBFILESUploadErrorWithPropertiesPropertiesError";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadErrorWithPropertiesSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadErrorWithPropertiesSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadErrorWithPropertiesSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadErrorWithPropertiesPath:
    result = prime * result + [self.path hash];
  case DBFILESUploadErrorWithPropertiesOther:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadErrorWithPropertiesPropertiesError:
    result = prime * result + [self.propertiesError hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadErrorWithProperties:other];
}

- (BOOL)isEqualToUploadErrorWithProperties:(DBFILESUploadErrorWithProperties *)anUploadErrorWithProperties {
  if (self == anUploadErrorWithProperties) {
    return YES;
  }
  if (self.tag != anUploadErrorWithProperties.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadErrorWithPropertiesPath:
    return [self.path isEqual:anUploadErrorWithProperties.path];
  case DBFILESUploadErrorWithPropertiesOther:
    return [[self tagName] isEqual:[anUploadErrorWithProperties tagName]];
  case DBFILESUploadErrorWithPropertiesPropertiesError:
    return [self.propertiesError isEqual:anUploadErrorWithProperties.propertiesError];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadErrorWithPropertiesSerializer

+ (NSDictionary *)serialize:(DBFILESUploadErrorWithProperties *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESUploadWriteFailedSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else if ([valueObj isPropertiesError]) {
    jsonDict[@"properties_error"] =
        [[DBFILESInvalidPropertyGroupErrorSerializer serialize:valueObj.propertiesError] mutableCopy];
    jsonDict[@".tag"] = @"properties_error";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESUploadErrorWithProperties *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"path"]) {
    DBFILESUploadWriteFailed *path = [DBFILESUploadWriteFailedSerializer deserialize:valueDict];
    return [[DBFILESUploadErrorWithProperties alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESUploadErrorWithProperties alloc] initWithOther];
  } else if ([tag isEqualToString:@"properties_error"]) {
    DBFILESInvalidPropertyGroupError *propertiesError =
        [DBFILESInvalidPropertyGroupErrorSerializer deserialize:valueDict[@"properties_error"]];
    return [[DBFILESUploadErrorWithProperties alloc] initWithPropertiesError:propertiesError];
  } else {
    return [[DBFILESUploadErrorWithProperties alloc] initWithOther];
  }
}

@end

#import "DBFILESUploadSessionAppendArg.h"
#import "DBFILESUploadSessionCursor.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionAppendArg

#pragma mark - Constructors

- (instancetype)initWithCursor:(DBFILESUploadSessionCursor *)cursor close:(NSNumber *)close {

  self = [super init];
  if (self) {
    _cursor = cursor;
    _close = close ?: @NO;
  }
  return self;
}

- (instancetype)initWithCursor:(DBFILESUploadSessionCursor *)cursor {
  return [self initWithCursor:cursor close:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionAppendArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionAppendArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionAppendArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.cursor hash];
  result = prime * result + [self.close hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionAppendArg:other];
}

- (BOOL)isEqualToUploadSessionAppendArg:(DBFILESUploadSessionAppendArg *)anUploadSessionAppendArg {
  if (self == anUploadSessionAppendArg) {
    return YES;
  }
  if (![self.cursor isEqual:anUploadSessionAppendArg.cursor]) {
    return NO;
  }
  if (![self.close isEqual:anUploadSessionAppendArg.close]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionAppendArgSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionAppendArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"cursor"] = [DBFILESUploadSessionCursorSerializer serialize:valueObj.cursor];
  jsonDict[@"close"] = valueObj.close;

  return jsonDict;
}

+ (DBFILESUploadSessionAppendArg *)deserialize:(NSDictionary *)valueDict {
  DBFILESUploadSessionCursor *cursor = [DBFILESUploadSessionCursorSerializer deserialize:valueDict[@"cursor"]];
  NSNumber *close = valueDict[@"close"] ?: @NO;

  return [[DBFILESUploadSessionAppendArg alloc] initWithCursor:cursor close:close];
}

@end

#import "DBFILESUploadSessionCursor.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionCursor

#pragma mark - Constructors

- (instancetype)initWithSessionId:(NSString *)sessionId offset:(NSNumber *)offset {

  self = [super init];
  if (self) {
    _sessionId = sessionId;
    _offset = offset;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionCursorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionCursorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionCursorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.sessionId hash];
  result = prime * result + [self.offset hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionCursor:other];
}

- (BOOL)isEqualToUploadSessionCursor:(DBFILESUploadSessionCursor *)anUploadSessionCursor {
  if (self == anUploadSessionCursor) {
    return YES;
  }
  if (![self.sessionId isEqual:anUploadSessionCursor.sessionId]) {
    return NO;
  }
  if (![self.offset isEqual:anUploadSessionCursor.offset]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionCursorSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionCursor *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"session_id"] = valueObj.sessionId;
  jsonDict[@"offset"] = valueObj.offset;

  return jsonDict;
}

+ (DBFILESUploadSessionCursor *)deserialize:(NSDictionary *)valueDict {
  NSString *sessionId = valueDict[@"session_id"];
  NSNumber *offset = valueDict[@"offset"];

  return [[DBFILESUploadSessionCursor alloc] initWithSessionId:sessionId offset:offset];
}

@end

#import "DBFILESCommitInfo.h"
#import "DBFILESUploadSessionCursor.h"
#import "DBFILESUploadSessionFinishArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishArg

#pragma mark - Constructors

- (instancetype)initWithCursor:(DBFILESUploadSessionCursor *)cursor commit:(DBFILESCommitInfo *)commit {

  self = [super init];
  if (self) {
    _cursor = cursor;
    _commit = commit;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.cursor hash];
  result = prime * result + [self.commit hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishArg:other];
}

- (BOOL)isEqualToUploadSessionFinishArg:(DBFILESUploadSessionFinishArg *)anUploadSessionFinishArg {
  if (self == anUploadSessionFinishArg) {
    return YES;
  }
  if (![self.cursor isEqual:anUploadSessionFinishArg.cursor]) {
    return NO;
  }
  if (![self.commit isEqual:anUploadSessionFinishArg.commit]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishArgSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"cursor"] = [DBFILESUploadSessionCursorSerializer serialize:valueObj.cursor];
  jsonDict[@"commit"] = [DBFILESCommitInfoSerializer serialize:valueObj.commit];

  return jsonDict;
}

+ (DBFILESUploadSessionFinishArg *)deserialize:(NSDictionary *)valueDict {
  DBFILESUploadSessionCursor *cursor = [DBFILESUploadSessionCursorSerializer deserialize:valueDict[@"cursor"]];
  DBFILESCommitInfo *commit = [DBFILESCommitInfoSerializer deserialize:valueDict[@"commit"]];

  return [[DBFILESUploadSessionFinishArg alloc] initWithCursor:cursor commit:commit];
}

@end

#import "DBFILESUploadSessionFinishArg.h"
#import "DBFILESUploadSessionFinishBatchArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishBatchArg

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESUploadSessionFinishArg *> *)entries {
  [DBStoneValidators arrayValidator:nil maxItems:@(1000) itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _entries = entries;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishBatchArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishBatchArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishBatchArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishBatchArg:other];
}

- (BOOL)isEqualToUploadSessionFinishBatchArg:(DBFILESUploadSessionFinishBatchArg *)anUploadSessionFinishBatchArg {
  if (self == anUploadSessionFinishBatchArg) {
    return YES;
  }
  if (![self.entries isEqual:anUploadSessionFinishBatchArg.entries]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishBatchArgSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishBatchArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] = [DBArraySerializer serialize:valueObj.entries
                                            withBlock:^id(id elem0) {
                                              return [DBFILESUploadSessionFinishArgSerializer serialize:elem0];
                                            }];

  return jsonDict;
}

+ (DBFILESUploadSessionFinishBatchArg *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESUploadSessionFinishArg *> *entries =
      [DBArraySerializer deserialize:valueDict[@"entries"]
                           withBlock:^id(id elem0) {
                             return [DBFILESUploadSessionFinishArgSerializer deserialize:elem0];
                           }];

  return [[DBFILESUploadSessionFinishBatchArg alloc] initWithEntries:entries];
}

@end

#import "DBASYNCPollResultBase.h"
#import "DBFILESUploadSessionFinishBatchJobStatus.h"
#import "DBFILESUploadSessionFinishBatchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishBatchJobStatus

@synthesize complete = _complete;

#pragma mark - Constructors

- (instancetype)initWithInProgress {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchJobStatusInProgress;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESUploadSessionFinishBatchResult *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchJobStatusComplete;
    _complete = complete;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESUploadSessionFinishBatchResult *)complete {
  if (![self isComplete]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionFinishBatchJobStatusComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

#pragma mark - Tag state methods

- (BOOL)isInProgress {
  return _tag == DBFILESUploadSessionFinishBatchJobStatusInProgress;
}

- (BOOL)isComplete {
  return _tag == DBFILESUploadSessionFinishBatchJobStatusComplete;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadSessionFinishBatchJobStatusInProgress:
    return @"DBFILESUploadSessionFinishBatchJobStatusInProgress";
  case DBFILESUploadSessionFinishBatchJobStatusComplete:
    return @"DBFILESUploadSessionFinishBatchJobStatusComplete";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishBatchJobStatusSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishBatchJobStatusSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishBatchJobStatusSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadSessionFinishBatchJobStatusInProgress:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadSessionFinishBatchJobStatusComplete:
    result = prime * result + [self.complete hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishBatchJobStatus:other];
}

- (BOOL)isEqualToUploadSessionFinishBatchJobStatus:
    (DBFILESUploadSessionFinishBatchJobStatus *)anUploadSessionFinishBatchJobStatus {
  if (self == anUploadSessionFinishBatchJobStatus) {
    return YES;
  }
  if (self.tag != anUploadSessionFinishBatchJobStatus.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadSessionFinishBatchJobStatusInProgress:
    return [[self tagName] isEqual:[anUploadSessionFinishBatchJobStatus tagName]];
  case DBFILESUploadSessionFinishBatchJobStatusComplete:
    return [self.complete isEqual:anUploadSessionFinishBatchJobStatus.complete];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishBatchJobStatusSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishBatchJobStatus *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isInProgress]) {
    jsonDict[@".tag"] = @"in_progress";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESUploadSessionFinishBatchResultSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESUploadSessionFinishBatchJobStatus *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"in_progress"]) {
    return [[DBFILESUploadSessionFinishBatchJobStatus alloc] initWithInProgress];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESUploadSessionFinishBatchResult *complete =
        [DBFILESUploadSessionFinishBatchResultSerializer deserialize:valueDict];
    return [[DBFILESUploadSessionFinishBatchJobStatus alloc] initWithComplete:complete];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBASYNCLaunchResultBase.h"
#import "DBFILESUploadSessionFinishBatchLaunch.h"
#import "DBFILESUploadSessionFinishBatchResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishBatchLaunch

@synthesize asyncJobId = _asyncJobId;
@synthesize complete = _complete;

#pragma mark - Constructors

- (instancetype)initWithAsyncJobId:(NSString *)asyncJobId {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchLaunchAsyncJobId;
    _asyncJobId = asyncJobId;
  }
  return self;
}

- (instancetype)initWithComplete:(DBFILESUploadSessionFinishBatchResult *)complete {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchLaunchComplete;
    _complete = complete;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchLaunchOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)asyncJobId {
  if (![self isAsyncJobId]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionFinishBatchLaunchAsyncJobId, but was %@.", [self tagName]];
  }
  return _asyncJobId;
}

- (DBFILESUploadSessionFinishBatchResult *)complete {
  if (![self isComplete]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionFinishBatchLaunchComplete, but was %@.", [self tagName]];
  }
  return _complete;
}

#pragma mark - Tag state methods

- (BOOL)isAsyncJobId {
  return _tag == DBFILESUploadSessionFinishBatchLaunchAsyncJobId;
}

- (BOOL)isComplete {
  return _tag == DBFILESUploadSessionFinishBatchLaunchComplete;
}

- (BOOL)isOther {
  return _tag == DBFILESUploadSessionFinishBatchLaunchOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadSessionFinishBatchLaunchAsyncJobId:
    return @"DBFILESUploadSessionFinishBatchLaunchAsyncJobId";
  case DBFILESUploadSessionFinishBatchLaunchComplete:
    return @"DBFILESUploadSessionFinishBatchLaunchComplete";
  case DBFILESUploadSessionFinishBatchLaunchOther:
    return @"DBFILESUploadSessionFinishBatchLaunchOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishBatchLaunchSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishBatchLaunchSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishBatchLaunchSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadSessionFinishBatchLaunchAsyncJobId:
    result = prime * result + [self.asyncJobId hash];
  case DBFILESUploadSessionFinishBatchLaunchComplete:
    result = prime * result + [self.complete hash];
  case DBFILESUploadSessionFinishBatchLaunchOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishBatchLaunch:other];
}

- (BOOL)isEqualToUploadSessionFinishBatchLaunch:
    (DBFILESUploadSessionFinishBatchLaunch *)anUploadSessionFinishBatchLaunch {
  if (self == anUploadSessionFinishBatchLaunch) {
    return YES;
  }
  if (self.tag != anUploadSessionFinishBatchLaunch.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadSessionFinishBatchLaunchAsyncJobId:
    return [self.asyncJobId isEqual:anUploadSessionFinishBatchLaunch.asyncJobId];
  case DBFILESUploadSessionFinishBatchLaunchComplete:
    return [self.complete isEqual:anUploadSessionFinishBatchLaunch.complete];
  case DBFILESUploadSessionFinishBatchLaunchOther:
    return [[self tagName] isEqual:[anUploadSessionFinishBatchLaunch tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishBatchLaunchSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishBatchLaunch *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isAsyncJobId]) {
    jsonDict[@"async_job_id"] = valueObj.asyncJobId;
    jsonDict[@".tag"] = @"async_job_id";
  } else if ([valueObj isComplete]) {
    jsonDict[@"complete"] = [[DBFILESUploadSessionFinishBatchResultSerializer serialize:valueObj.complete] mutableCopy];
    jsonDict[@".tag"] = @"complete";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESUploadSessionFinishBatchLaunch *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"async_job_id"]) {
    NSString *asyncJobId = valueDict[@"async_job_id"];
    return [[DBFILESUploadSessionFinishBatchLaunch alloc] initWithAsyncJobId:asyncJobId];
  } else if ([tag isEqualToString:@"complete"]) {
    DBFILESUploadSessionFinishBatchResult *complete =
        [DBFILESUploadSessionFinishBatchResultSerializer deserialize:valueDict];
    return [[DBFILESUploadSessionFinishBatchLaunch alloc] initWithComplete:complete];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESUploadSessionFinishBatchLaunch alloc] initWithOther];
  } else {
    return [[DBFILESUploadSessionFinishBatchLaunch alloc] initWithOther];
  }
}

@end

#import "DBFILESUploadSessionFinishBatchResult.h"
#import "DBFILESUploadSessionFinishBatchResultEntry.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishBatchResult

#pragma mark - Constructors

- (instancetype)initWithEntries:(NSArray<DBFILESUploadSessionFinishBatchResultEntry *> *)entries {
  [DBStoneValidators arrayValidator:nil maxItems:nil itemValidator:nil](entries);

  self = [super init];
  if (self) {
    _entries = entries;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishBatchResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishBatchResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishBatchResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.entries hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishBatchResult:other];
}

- (BOOL)isEqualToUploadSessionFinishBatchResult:
    (DBFILESUploadSessionFinishBatchResult *)anUploadSessionFinishBatchResult {
  if (self == anUploadSessionFinishBatchResult) {
    return YES;
  }
  if (![self.entries isEqual:anUploadSessionFinishBatchResult.entries]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishBatchResultSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishBatchResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"entries"] =
      [DBArraySerializer serialize:valueObj.entries
                         withBlock:^id(id elem0) {
                           return [DBFILESUploadSessionFinishBatchResultEntrySerializer serialize:elem0];
                         }];

  return jsonDict;
}

+ (DBFILESUploadSessionFinishBatchResult *)deserialize:(NSDictionary *)valueDict {
  NSArray<DBFILESUploadSessionFinishBatchResultEntry *> *entries =
      [DBArraySerializer deserialize:valueDict[@"entries"]
                           withBlock:^id(id elem0) {
                             return [DBFILESUploadSessionFinishBatchResultEntrySerializer deserialize:elem0];
                           }];

  return [[DBFILESUploadSessionFinishBatchResult alloc] initWithEntries:entries];
}

@end

#import "DBFILESFileMetadata.h"
#import "DBFILESUploadSessionFinishBatchResultEntry.h"
#import "DBFILESUploadSessionFinishError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishBatchResultEntry

@synthesize success = _success;
@synthesize failure = _failure;

#pragma mark - Constructors

- (instancetype)initWithSuccess:(DBFILESFileMetadata *)success {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchResultEntrySuccess;
    _success = success;
  }
  return self;
}

- (instancetype)initWithFailure:(DBFILESUploadSessionFinishError *)failure {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishBatchResultEntryFailure;
    _failure = failure;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESFileMetadata *)success {
  if (![self isSuccess]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionFinishBatchResultEntrySuccess, but was %@.", [self tagName]];
  }
  return _success;
}

- (DBFILESUploadSessionFinishError *)failure {
  if (![self isFailure]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionFinishBatchResultEntryFailure, but was %@.", [self tagName]];
  }
  return _failure;
}

#pragma mark - Tag state methods

- (BOOL)isSuccess {
  return _tag == DBFILESUploadSessionFinishBatchResultEntrySuccess;
}

- (BOOL)isFailure {
  return _tag == DBFILESUploadSessionFinishBatchResultEntryFailure;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadSessionFinishBatchResultEntrySuccess:
    return @"DBFILESUploadSessionFinishBatchResultEntrySuccess";
  case DBFILESUploadSessionFinishBatchResultEntryFailure:
    return @"DBFILESUploadSessionFinishBatchResultEntryFailure";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishBatchResultEntrySerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishBatchResultEntrySerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishBatchResultEntrySerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadSessionFinishBatchResultEntrySuccess:
    result = prime * result + [self.success hash];
  case DBFILESUploadSessionFinishBatchResultEntryFailure:
    result = prime * result + [self.failure hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishBatchResultEntry:other];
}

- (BOOL)isEqualToUploadSessionFinishBatchResultEntry:
    (DBFILESUploadSessionFinishBatchResultEntry *)anUploadSessionFinishBatchResultEntry {
  if (self == anUploadSessionFinishBatchResultEntry) {
    return YES;
  }
  if (self.tag != anUploadSessionFinishBatchResultEntry.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadSessionFinishBatchResultEntrySuccess:
    return [self.success isEqual:anUploadSessionFinishBatchResultEntry.success];
  case DBFILESUploadSessionFinishBatchResultEntryFailure:
    return [self.failure isEqual:anUploadSessionFinishBatchResultEntry.failure];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishBatchResultEntrySerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishBatchResultEntry *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isSuccess]) {
    jsonDict[@"success"] = [[DBFILESFileMetadataSerializer serialize:valueObj.success] mutableCopy];
    jsonDict[@".tag"] = @"success";
  } else if ([valueObj isFailure]) {
    jsonDict[@"failure"] = [[DBFILESUploadSessionFinishErrorSerializer serialize:valueObj.failure] mutableCopy];
    jsonDict[@".tag"] = @"failure";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESUploadSessionFinishBatchResultEntry *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"success"]) {
    DBFILESFileMetadata *success = [DBFILESFileMetadataSerializer deserialize:valueDict];
    return [[DBFILESUploadSessionFinishBatchResultEntry alloc] initWithSuccess:success];
  } else if ([tag isEqualToString:@"failure"]) {
    DBFILESUploadSessionFinishError *failure =
        [DBFILESUploadSessionFinishErrorSerializer deserialize:valueDict[@"failure"]];
    return [[DBFILESUploadSessionFinishBatchResultEntry alloc] initWithFailure:failure];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end

#import "DBFILESUploadSessionFinishError.h"
#import "DBFILESUploadSessionLookupError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionFinishError

@synthesize lookupFailed = _lookupFailed;
@synthesize path = _path;

#pragma mark - Constructors

- (instancetype)initWithLookupFailed:(DBFILESUploadSessionLookupError *)lookupFailed {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishErrorLookupFailed;
    _lookupFailed = lookupFailed;
  }
  return self;
}

- (instancetype)initWithPath:(DBFILESWriteError *)path {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishErrorPath;
    _path = path;
  }
  return self;
}

- (instancetype)initWithTooManySharedFolderTargets {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishErrorTooManySharedFolderTargets;
  }
  return self;
}

- (instancetype)initWithTooManyWriteOperations {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishErrorTooManyWriteOperations;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionFinishErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESUploadSessionLookupError *)lookupFailed {
  if (![self isLookupFailed]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionFinishErrorLookupFailed, but was %@.", [self tagName]];
  }
  return _lookupFailed;
}

- (DBFILESWriteError *)path {
  if (![self isPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESUploadSessionFinishErrorPath, but was %@.", [self tagName]];
  }
  return _path;
}

#pragma mark - Tag state methods

- (BOOL)isLookupFailed {
  return _tag == DBFILESUploadSessionFinishErrorLookupFailed;
}

- (BOOL)isPath {
  return _tag == DBFILESUploadSessionFinishErrorPath;
}

- (BOOL)isTooManySharedFolderTargets {
  return _tag == DBFILESUploadSessionFinishErrorTooManySharedFolderTargets;
}

- (BOOL)isTooManyWriteOperations {
  return _tag == DBFILESUploadSessionFinishErrorTooManyWriteOperations;
}

- (BOOL)isOther {
  return _tag == DBFILESUploadSessionFinishErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadSessionFinishErrorLookupFailed:
    return @"DBFILESUploadSessionFinishErrorLookupFailed";
  case DBFILESUploadSessionFinishErrorPath:
    return @"DBFILESUploadSessionFinishErrorPath";
  case DBFILESUploadSessionFinishErrorTooManySharedFolderTargets:
    return @"DBFILESUploadSessionFinishErrorTooManySharedFolderTargets";
  case DBFILESUploadSessionFinishErrorTooManyWriteOperations:
    return @"DBFILESUploadSessionFinishErrorTooManyWriteOperations";
  case DBFILESUploadSessionFinishErrorOther:
    return @"DBFILESUploadSessionFinishErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionFinishErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionFinishErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionFinishErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadSessionFinishErrorLookupFailed:
    result = prime * result + [self.lookupFailed hash];
  case DBFILESUploadSessionFinishErrorPath:
    result = prime * result + [self.path hash];
  case DBFILESUploadSessionFinishErrorTooManySharedFolderTargets:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadSessionFinishErrorTooManyWriteOperations:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadSessionFinishErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionFinishError:other];
}

- (BOOL)isEqualToUploadSessionFinishError:(DBFILESUploadSessionFinishError *)anUploadSessionFinishError {
  if (self == anUploadSessionFinishError) {
    return YES;
  }
  if (self.tag != anUploadSessionFinishError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadSessionFinishErrorLookupFailed:
    return [self.lookupFailed isEqual:anUploadSessionFinishError.lookupFailed];
  case DBFILESUploadSessionFinishErrorPath:
    return [self.path isEqual:anUploadSessionFinishError.path];
  case DBFILESUploadSessionFinishErrorTooManySharedFolderTargets:
    return [[self tagName] isEqual:[anUploadSessionFinishError tagName]];
  case DBFILESUploadSessionFinishErrorTooManyWriteOperations:
    return [[self tagName] isEqual:[anUploadSessionFinishError tagName]];
  case DBFILESUploadSessionFinishErrorOther:
    return [[self tagName] isEqual:[anUploadSessionFinishError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionFinishErrorSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionFinishError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isLookupFailed]) {
    jsonDict[@"lookup_failed"] =
        [[DBFILESUploadSessionLookupErrorSerializer serialize:valueObj.lookupFailed] mutableCopy];
    jsonDict[@".tag"] = @"lookup_failed";
  } else if ([valueObj isPath]) {
    jsonDict[@"path"] = [[DBFILESWriteErrorSerializer serialize:valueObj.path] mutableCopy];
    jsonDict[@".tag"] = @"path";
  } else if ([valueObj isTooManySharedFolderTargets]) {
    jsonDict[@".tag"] = @"too_many_shared_folder_targets";
  } else if ([valueObj isTooManyWriteOperations]) {
    jsonDict[@".tag"] = @"too_many_write_operations";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESUploadSessionFinishError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"lookup_failed"]) {
    DBFILESUploadSessionLookupError *lookupFailed =
        [DBFILESUploadSessionLookupErrorSerializer deserialize:valueDict[@"lookup_failed"]];
    return [[DBFILESUploadSessionFinishError alloc] initWithLookupFailed:lookupFailed];
  } else if ([tag isEqualToString:@"path"]) {
    DBFILESWriteError *path = [DBFILESWriteErrorSerializer deserialize:valueDict[@"path"]];
    return [[DBFILESUploadSessionFinishError alloc] initWithPath:path];
  } else if ([tag isEqualToString:@"too_many_shared_folder_targets"]) {
    return [[DBFILESUploadSessionFinishError alloc] initWithTooManySharedFolderTargets];
  } else if ([tag isEqualToString:@"too_many_write_operations"]) {
    return [[DBFILESUploadSessionFinishError alloc] initWithTooManyWriteOperations];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESUploadSessionFinishError alloc] initWithOther];
  } else {
    return [[DBFILESUploadSessionFinishError alloc] initWithOther];
  }
}

@end

#import "DBFILESUploadSessionLookupError.h"
#import "DBFILESUploadSessionOffsetError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionLookupError

@synthesize incorrectOffset = _incorrectOffset;

#pragma mark - Constructors

- (instancetype)initWithNotFound {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionLookupErrorNotFound;
  }
  return self;
}

- (instancetype)initWithIncorrectOffset:(DBFILESUploadSessionOffsetError *)incorrectOffset {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionLookupErrorIncorrectOffset;
    _incorrectOffset = incorrectOffset;
  }
  return self;
}

- (instancetype)initWithClosed {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionLookupErrorClosed;
  }
  return self;
}

- (instancetype)initWithNotClosed {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionLookupErrorNotClosed;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESUploadSessionLookupErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (DBFILESUploadSessionOffsetError *)incorrectOffset {
  if (![self isIncorrectOffset]) {
    [NSException
         raise:@"IllegalStateException"
        format:@"Invalid tag: required DBFILESUploadSessionLookupErrorIncorrectOffset, but was %@.", [self tagName]];
  }
  return _incorrectOffset;
}

#pragma mark - Tag state methods

- (BOOL)isNotFound {
  return _tag == DBFILESUploadSessionLookupErrorNotFound;
}

- (BOOL)isIncorrectOffset {
  return _tag == DBFILESUploadSessionLookupErrorIncorrectOffset;
}

- (BOOL)isClosed {
  return _tag == DBFILESUploadSessionLookupErrorClosed;
}

- (BOOL)isNotClosed {
  return _tag == DBFILESUploadSessionLookupErrorNotClosed;
}

- (BOOL)isOther {
  return _tag == DBFILESUploadSessionLookupErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESUploadSessionLookupErrorNotFound:
    return @"DBFILESUploadSessionLookupErrorNotFound";
  case DBFILESUploadSessionLookupErrorIncorrectOffset:
    return @"DBFILESUploadSessionLookupErrorIncorrectOffset";
  case DBFILESUploadSessionLookupErrorClosed:
    return @"DBFILESUploadSessionLookupErrorClosed";
  case DBFILESUploadSessionLookupErrorNotClosed:
    return @"DBFILESUploadSessionLookupErrorNotClosed";
  case DBFILESUploadSessionLookupErrorOther:
    return @"DBFILESUploadSessionLookupErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionLookupErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionLookupErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionLookupErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESUploadSessionLookupErrorNotFound:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadSessionLookupErrorIncorrectOffset:
    result = prime * result + [self.incorrectOffset hash];
  case DBFILESUploadSessionLookupErrorClosed:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadSessionLookupErrorNotClosed:
    result = prime * result + [[self tagName] hash];
  case DBFILESUploadSessionLookupErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionLookupError:other];
}

- (BOOL)isEqualToUploadSessionLookupError:(DBFILESUploadSessionLookupError *)anUploadSessionLookupError {
  if (self == anUploadSessionLookupError) {
    return YES;
  }
  if (self.tag != anUploadSessionLookupError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESUploadSessionLookupErrorNotFound:
    return [[self tagName] isEqual:[anUploadSessionLookupError tagName]];
  case DBFILESUploadSessionLookupErrorIncorrectOffset:
    return [self.incorrectOffset isEqual:anUploadSessionLookupError.incorrectOffset];
  case DBFILESUploadSessionLookupErrorClosed:
    return [[self tagName] isEqual:[anUploadSessionLookupError tagName]];
  case DBFILESUploadSessionLookupErrorNotClosed:
    return [[self tagName] isEqual:[anUploadSessionLookupError tagName]];
  case DBFILESUploadSessionLookupErrorOther:
    return [[self tagName] isEqual:[anUploadSessionLookupError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionLookupErrorSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionLookupError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isNotFound]) {
    jsonDict[@".tag"] = @"not_found";
  } else if ([valueObj isIncorrectOffset]) {
    jsonDict[@"incorrect_offset"] =
        [[DBFILESUploadSessionOffsetErrorSerializer serialize:valueObj.incorrectOffset] mutableCopy];
    jsonDict[@".tag"] = @"incorrect_offset";
  } else if ([valueObj isClosed]) {
    jsonDict[@".tag"] = @"closed";
  } else if ([valueObj isNotClosed]) {
    jsonDict[@".tag"] = @"not_closed";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESUploadSessionLookupError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"not_found"]) {
    return [[DBFILESUploadSessionLookupError alloc] initWithNotFound];
  } else if ([tag isEqualToString:@"incorrect_offset"]) {
    DBFILESUploadSessionOffsetError *incorrectOffset =
        [DBFILESUploadSessionOffsetErrorSerializer deserialize:valueDict];
    return [[DBFILESUploadSessionLookupError alloc] initWithIncorrectOffset:incorrectOffset];
  } else if ([tag isEqualToString:@"closed"]) {
    return [[DBFILESUploadSessionLookupError alloc] initWithClosed];
  } else if ([tag isEqualToString:@"not_closed"]) {
    return [[DBFILESUploadSessionLookupError alloc] initWithNotClosed];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESUploadSessionLookupError alloc] initWithOther];
  } else {
    return [[DBFILESUploadSessionLookupError alloc] initWithOther];
  }
}

@end

#import "DBFILESUploadSessionOffsetError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionOffsetError

#pragma mark - Constructors

- (instancetype)initWithCorrectOffset:(NSNumber *)correctOffset {

  self = [super init];
  if (self) {
    _correctOffset = correctOffset;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionOffsetErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionOffsetErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionOffsetErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.correctOffset hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionOffsetError:other];
}

- (BOOL)isEqualToUploadSessionOffsetError:(DBFILESUploadSessionOffsetError *)anUploadSessionOffsetError {
  if (self == anUploadSessionOffsetError) {
    return YES;
  }
  if (![self.correctOffset isEqual:anUploadSessionOffsetError.correctOffset]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionOffsetErrorSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionOffsetError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"correct_offset"] = valueObj.correctOffset;

  return jsonDict;
}

+ (DBFILESUploadSessionOffsetError *)deserialize:(NSDictionary *)valueDict {
  NSNumber *correctOffset = valueDict[@"correct_offset"];

  return [[DBFILESUploadSessionOffsetError alloc] initWithCorrectOffset:correctOffset];
}

@end

#import "DBFILESUploadSessionStartArg.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionStartArg

#pragma mark - Constructors

- (instancetype)initWithClose:(NSNumber *)close {

  self = [super init];
  if (self) {
    _close = close ?: @NO;
  }
  return self;
}

- (instancetype)initDefault {
  return [self initWithClose:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionStartArgSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionStartArgSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionStartArgSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.close hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionStartArg:other];
}

- (BOOL)isEqualToUploadSessionStartArg:(DBFILESUploadSessionStartArg *)anUploadSessionStartArg {
  if (self == anUploadSessionStartArg) {
    return YES;
  }
  if (![self.close isEqual:anUploadSessionStartArg.close]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionStartArgSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionStartArg *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"close"] = valueObj.close;

  return jsonDict;
}

+ (DBFILESUploadSessionStartArg *)deserialize:(NSDictionary *)valueDict {
  NSNumber *close = valueDict[@"close"] ?: @NO;

  return [[DBFILESUploadSessionStartArg alloc] initWithClose:close];
}

@end

#import "DBFILESUploadSessionStartResult.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadSessionStartResult

#pragma mark - Constructors

- (instancetype)initWithSessionId:(NSString *)sessionId {

  self = [super init];
  if (self) {
    _sessionId = sessionId;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadSessionStartResultSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadSessionStartResultSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadSessionStartResultSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.sessionId hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadSessionStartResult:other];
}

- (BOOL)isEqualToUploadSessionStartResult:(DBFILESUploadSessionStartResult *)anUploadSessionStartResult {
  if (self == anUploadSessionStartResult) {
    return YES;
  }
  if (![self.sessionId isEqual:anUploadSessionStartResult.sessionId]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadSessionStartResultSerializer

+ (NSDictionary *)serialize:(DBFILESUploadSessionStartResult *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"session_id"] = valueObj.sessionId;

  return jsonDict;
}

+ (DBFILESUploadSessionStartResult *)deserialize:(NSDictionary *)valueDict {
  NSString *sessionId = valueDict[@"session_id"];

  return [[DBFILESUploadSessionStartResult alloc] initWithSessionId:sessionId];
}

@end

#import "DBFILESUploadWriteFailed.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESUploadWriteFailed

#pragma mark - Constructors

- (instancetype)initWithReason:(DBFILESWriteError *)reason uploadSessionId:(NSString *)uploadSessionId {

  self = [super init];
  if (self) {
    _reason = reason;
    _uploadSessionId = uploadSessionId;
  }
  return self;
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESUploadWriteFailedSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESUploadWriteFailedSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESUploadWriteFailedSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  result = prime * result + [self.reason hash];
  result = prime * result + [self.uploadSessionId hash];

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToUploadWriteFailed:other];
}

- (BOOL)isEqualToUploadWriteFailed:(DBFILESUploadWriteFailed *)anUploadWriteFailed {
  if (self == anUploadWriteFailed) {
    return YES;
  }
  if (![self.reason isEqual:anUploadWriteFailed.reason]) {
    return NO;
  }
  if (![self.uploadSessionId isEqual:anUploadWriteFailed.uploadSessionId]) {
    return NO;
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESUploadWriteFailedSerializer

+ (NSDictionary *)serialize:(DBFILESUploadWriteFailed *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  jsonDict[@"reason"] = [DBFILESWriteErrorSerializer serialize:valueObj.reason];
  jsonDict[@"upload_session_id"] = valueObj.uploadSessionId;

  return jsonDict;
}

+ (DBFILESUploadWriteFailed *)deserialize:(NSDictionary *)valueDict {
  DBFILESWriteError *reason = [DBFILESWriteErrorSerializer deserialize:valueDict[@"reason"]];
  NSString *uploadSessionId = valueDict[@"upload_session_id"];

  return [[DBFILESUploadWriteFailed alloc] initWithReason:reason uploadSessionId:uploadSessionId];
}

@end

#import "DBFILESDimensions.h"
#import "DBFILESGpsCoordinates.h"
#import "DBFILESMediaMetadata.h"
#import "DBFILESVideoMetadata.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESVideoMetadata

#pragma mark - Constructors

- (instancetype)initWithDimensions:(DBFILESDimensions *)dimensions
                          location:(DBFILESGpsCoordinates *)location
                         timeTaken:(NSDate *)timeTaken
                          duration:(NSNumber *)duration {

  self = [super initWithDimensions:dimensions location:location timeTaken:timeTaken];
  if (self) {
    _duration = duration;
  }
  return self;
}

- (instancetype)initDefault {
  return [self initWithDimensions:nil location:nil timeTaken:nil duration:nil];
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESVideoMetadataSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESVideoMetadataSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESVideoMetadataSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  if (self.dimensions) {
    result = prime * result + [self.dimensions hash];
  }
  if (self.location) {
    result = prime * result + [self.location hash];
  }
  if (self.timeTaken) {
    result = prime * result + [self.timeTaken hash];
  }
  if (self.duration) {
    result = prime * result + [self.duration hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToVideoMetadata:other];
}

- (BOOL)isEqualToVideoMetadata:(DBFILESVideoMetadata *)aVideoMetadata {
  if (self == aVideoMetadata) {
    return YES;
  }
  if (self.dimensions) {
    if (![self.dimensions isEqual:aVideoMetadata.dimensions]) {
      return NO;
    }
  }
  if (self.location) {
    if (![self.location isEqual:aVideoMetadata.location]) {
      return NO;
    }
  }
  if (self.timeTaken) {
    if (![self.timeTaken isEqual:aVideoMetadata.timeTaken]) {
      return NO;
    }
  }
  if (self.duration) {
    if (![self.duration isEqual:aVideoMetadata.duration]) {
      return NO;
    }
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESVideoMetadataSerializer

+ (NSDictionary *)serialize:(DBFILESVideoMetadata *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if (valueObj.dimensions) {
    jsonDict[@"dimensions"] = [DBFILESDimensionsSerializer serialize:valueObj.dimensions];
  }
  if (valueObj.location) {
    jsonDict[@"location"] = [DBFILESGpsCoordinatesSerializer serialize:valueObj.location];
  }
  if (valueObj.timeTaken) {
    jsonDict[@"time_taken"] = [DBNSDateSerializer serialize:valueObj.timeTaken dateFormat:@"%Y-%m-%dT%H:%M:%SZ"];
  }
  if (valueObj.duration) {
    jsonDict[@"duration"] = valueObj.duration;
  }

  return jsonDict;
}

+ (DBFILESVideoMetadata *)deserialize:(NSDictionary *)valueDict {
  DBFILESDimensions *dimensions =
      valueDict[@"dimensions"] ? [DBFILESDimensionsSerializer deserialize:valueDict[@"dimensions"]] : nil;
  DBFILESGpsCoordinates *location =
      valueDict[@"location"] ? [DBFILESGpsCoordinatesSerializer deserialize:valueDict[@"location"]] : nil;
  NSDate *timeTaken = valueDict[@"time_taken"]
                          ? [DBNSDateSerializer deserialize:valueDict[@"time_taken"] dateFormat:@"%Y-%m-%dT%H:%M:%SZ"]
                          : nil;
  NSNumber *duration = valueDict[@"duration"] ?: nil;

  return [[DBFILESVideoMetadata alloc] initWithDimensions:dimensions
                                                 location:location
                                                timeTaken:timeTaken
                                                 duration:duration];
}

@end

#import "DBFILESWriteConflictError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESWriteConflictError

#pragma mark - Constructors

- (instancetype)initWithFile {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteConflictErrorFile;
  }
  return self;
}

- (instancetype)initWithFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteConflictErrorFolder;
  }
  return self;
}

- (instancetype)initWithFileAncestor {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteConflictErrorFileAncestor;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteConflictErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

#pragma mark - Tag state methods

- (BOOL)isFile {
  return _tag == DBFILESWriteConflictErrorFile;
}

- (BOOL)isFolder {
  return _tag == DBFILESWriteConflictErrorFolder;
}

- (BOOL)isFileAncestor {
  return _tag == DBFILESWriteConflictErrorFileAncestor;
}

- (BOOL)isOther {
  return _tag == DBFILESWriteConflictErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESWriteConflictErrorFile:
    return @"DBFILESWriteConflictErrorFile";
  case DBFILESWriteConflictErrorFolder:
    return @"DBFILESWriteConflictErrorFolder";
  case DBFILESWriteConflictErrorFileAncestor:
    return @"DBFILESWriteConflictErrorFileAncestor";
  case DBFILESWriteConflictErrorOther:
    return @"DBFILESWriteConflictErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESWriteConflictErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESWriteConflictErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESWriteConflictErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESWriteConflictErrorFile:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteConflictErrorFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteConflictErrorFileAncestor:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteConflictErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToWriteConflictError:other];
}

- (BOOL)isEqualToWriteConflictError:(DBFILESWriteConflictError *)aWriteConflictError {
  if (self == aWriteConflictError) {
    return YES;
  }
  if (self.tag != aWriteConflictError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESWriteConflictErrorFile:
    return [[self tagName] isEqual:[aWriteConflictError tagName]];
  case DBFILESWriteConflictErrorFolder:
    return [[self tagName] isEqual:[aWriteConflictError tagName]];
  case DBFILESWriteConflictErrorFileAncestor:
    return [[self tagName] isEqual:[aWriteConflictError tagName]];
  case DBFILESWriteConflictErrorOther:
    return [[self tagName] isEqual:[aWriteConflictError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESWriteConflictErrorSerializer

+ (NSDictionary *)serialize:(DBFILESWriteConflictError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isFile]) {
    jsonDict[@".tag"] = @"file";
  } else if ([valueObj isFolder]) {
    jsonDict[@".tag"] = @"folder";
  } else if ([valueObj isFileAncestor]) {
    jsonDict[@".tag"] = @"file_ancestor";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESWriteConflictError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"file"]) {
    return [[DBFILESWriteConflictError alloc] initWithFile];
  } else if ([tag isEqualToString:@"folder"]) {
    return [[DBFILESWriteConflictError alloc] initWithFolder];
  } else if ([tag isEqualToString:@"file_ancestor"]) {
    return [[DBFILESWriteConflictError alloc] initWithFileAncestor];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESWriteConflictError alloc] initWithOther];
  } else {
    return [[DBFILESWriteConflictError alloc] initWithOther];
  }
}

@end

#import "DBFILESWriteConflictError.h"
#import "DBFILESWriteError.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESWriteError

@synthesize malformedPath = _malformedPath;
@synthesize conflict = _conflict;

#pragma mark - Constructors

- (instancetype)initWithMalformedPath:(NSString *)malformedPath {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorMalformedPath;
    _malformedPath = malformedPath;
  }
  return self;
}

- (instancetype)initWithConflict:(DBFILESWriteConflictError *)conflict {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorConflict;
    _conflict = conflict;
  }
  return self;
}

- (instancetype)initWithNoWritePermission {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorNoWritePermission;
  }
  return self;
}

- (instancetype)initWithInsufficientSpace {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorInsufficientSpace;
  }
  return self;
}

- (instancetype)initWithDisallowedName {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorDisallowedName;
  }
  return self;
}

- (instancetype)initWithTeamFolder {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorTeamFolder;
  }
  return self;
}

- (instancetype)initWithOther {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteErrorOther;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)malformedPath {
  if (![self isMalformedPath]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESWriteErrorMalformedPath, but was %@.", [self tagName]];
  }
  return _malformedPath;
}

- (DBFILESWriteConflictError *)conflict {
  if (![self isConflict]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESWriteErrorConflict, but was %@.", [self tagName]];
  }
  return _conflict;
}

#pragma mark - Tag state methods

- (BOOL)isMalformedPath {
  return _tag == DBFILESWriteErrorMalformedPath;
}

- (BOOL)isConflict {
  return _tag == DBFILESWriteErrorConflict;
}

- (BOOL)isNoWritePermission {
  return _tag == DBFILESWriteErrorNoWritePermission;
}

- (BOOL)isInsufficientSpace {
  return _tag == DBFILESWriteErrorInsufficientSpace;
}

- (BOOL)isDisallowedName {
  return _tag == DBFILESWriteErrorDisallowedName;
}

- (BOOL)isTeamFolder {
  return _tag == DBFILESWriteErrorTeamFolder;
}

- (BOOL)isOther {
  return _tag == DBFILESWriteErrorOther;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESWriteErrorMalformedPath:
    return @"DBFILESWriteErrorMalformedPath";
  case DBFILESWriteErrorConflict:
    return @"DBFILESWriteErrorConflict";
  case DBFILESWriteErrorNoWritePermission:
    return @"DBFILESWriteErrorNoWritePermission";
  case DBFILESWriteErrorInsufficientSpace:
    return @"DBFILESWriteErrorInsufficientSpace";
  case DBFILESWriteErrorDisallowedName:
    return @"DBFILESWriteErrorDisallowedName";
  case DBFILESWriteErrorTeamFolder:
    return @"DBFILESWriteErrorTeamFolder";
  case DBFILESWriteErrorOther:
    return @"DBFILESWriteErrorOther";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESWriteErrorSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESWriteErrorSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESWriteErrorSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESWriteErrorMalformedPath:
    if (self.malformedPath) {
      result = prime * result + [self.malformedPath hash];
    }
  case DBFILESWriteErrorConflict:
    result = prime * result + [self.conflict hash];
  case DBFILESWriteErrorNoWritePermission:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteErrorInsufficientSpace:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteErrorDisallowedName:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteErrorTeamFolder:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteErrorOther:
    result = prime * result + [[self tagName] hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToWriteError:other];
}

- (BOOL)isEqualToWriteError:(DBFILESWriteError *)aWriteError {
  if (self == aWriteError) {
    return YES;
  }
  if (self.tag != aWriteError.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESWriteErrorMalformedPath:
    if (self.malformedPath) {
      return [self.malformedPath isEqual:aWriteError.malformedPath];
    }
  case DBFILESWriteErrorConflict:
    return [self.conflict isEqual:aWriteError.conflict];
  case DBFILESWriteErrorNoWritePermission:
    return [[self tagName] isEqual:[aWriteError tagName]];
  case DBFILESWriteErrorInsufficientSpace:
    return [[self tagName] isEqual:[aWriteError tagName]];
  case DBFILESWriteErrorDisallowedName:
    return [[self tagName] isEqual:[aWriteError tagName]];
  case DBFILESWriteErrorTeamFolder:
    return [[self tagName] isEqual:[aWriteError tagName]];
  case DBFILESWriteErrorOther:
    return [[self tagName] isEqual:[aWriteError tagName]];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESWriteErrorSerializer

+ (NSDictionary *)serialize:(DBFILESWriteError *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isMalformedPath]) {
    if (valueObj.malformedPath) {
      jsonDict[@"malformed_path"] = valueObj.malformedPath;
    }
    jsonDict[@".tag"] = @"malformed_path";
  } else if ([valueObj isConflict]) {
    jsonDict[@"conflict"] = [[DBFILESWriteConflictErrorSerializer serialize:valueObj.conflict] mutableCopy];
    jsonDict[@".tag"] = @"conflict";
  } else if ([valueObj isNoWritePermission]) {
    jsonDict[@".tag"] = @"no_write_permission";
  } else if ([valueObj isInsufficientSpace]) {
    jsonDict[@".tag"] = @"insufficient_space";
  } else if ([valueObj isDisallowedName]) {
    jsonDict[@".tag"] = @"disallowed_name";
  } else if ([valueObj isTeamFolder]) {
    jsonDict[@".tag"] = @"team_folder";
  } else if ([valueObj isOther]) {
    jsonDict[@".tag"] = @"other";
  } else {
    jsonDict[@".tag"] = @"other";
  }

  return jsonDict;
}

+ (DBFILESWriteError *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"malformed_path"]) {
    NSString *malformedPath = valueDict[@"malformed_path"] ? valueDict[@"malformed_path"] : nil;
    return [[DBFILESWriteError alloc] initWithMalformedPath:malformedPath];
  } else if ([tag isEqualToString:@"conflict"]) {
    DBFILESWriteConflictError *conflict = [DBFILESWriteConflictErrorSerializer deserialize:valueDict[@"conflict"]];
    return [[DBFILESWriteError alloc] initWithConflict:conflict];
  } else if ([tag isEqualToString:@"no_write_permission"]) {
    return [[DBFILESWriteError alloc] initWithNoWritePermission];
  } else if ([tag isEqualToString:@"insufficient_space"]) {
    return [[DBFILESWriteError alloc] initWithInsufficientSpace];
  } else if ([tag isEqualToString:@"disallowed_name"]) {
    return [[DBFILESWriteError alloc] initWithDisallowedName];
  } else if ([tag isEqualToString:@"team_folder"]) {
    return [[DBFILESWriteError alloc] initWithTeamFolder];
  } else if ([tag isEqualToString:@"other"]) {
    return [[DBFILESWriteError alloc] initWithOther];
  } else {
    return [[DBFILESWriteError alloc] initWithOther];
  }
}

@end

#import "DBFILESWriteMode.h"
#import "DBStoneSerializers.h"
#import "DBStoneValidators.h"

#pragma mark - API Object

@implementation DBFILESWriteMode

@synthesize update = _update;

#pragma mark - Constructors

- (instancetype)initWithAdd {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteModeAdd;
  }
  return self;
}

- (instancetype)initWithOverwrite {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteModeOverwrite;
  }
  return self;
}

- (instancetype)initWithUpdate:(NSString *)update {
  self = [super init];
  if (self) {
    _tag = DBFILESWriteModeUpdate;
    _update = update;
  }
  return self;
}

#pragma mark - Instance field accessors

- (NSString *)update {
  if (![self isUpdate]) {
    [NSException raise:@"IllegalStateException"
                format:@"Invalid tag: required DBFILESWriteModeUpdate, but was %@.", [self tagName]];
  }
  return _update;
}

#pragma mark - Tag state methods

- (BOOL)isAdd {
  return _tag == DBFILESWriteModeAdd;
}

- (BOOL)isOverwrite {
  return _tag == DBFILESWriteModeOverwrite;
}

- (BOOL)isUpdate {
  return _tag == DBFILESWriteModeUpdate;
}

- (NSString *)tagName {
  switch (_tag) {
  case DBFILESWriteModeAdd:
    return @"DBFILESWriteModeAdd";
  case DBFILESWriteModeOverwrite:
    return @"DBFILESWriteModeOverwrite";
  case DBFILESWriteModeUpdate:
    return @"DBFILESWriteModeUpdate";
  }

  @throw([NSException exceptionWithName:@"InvalidTag" reason:@"Tag has an unknown value." userInfo:nil]);
}

#pragma mark - Serialization methods

+ (NSDictionary *)serialize:(id)instance {
  return [DBFILESWriteModeSerializer serialize:instance];
}

+ (id)deserialize:(NSDictionary *)dict {
  return [DBFILESWriteModeSerializer deserialize:dict];
}

#pragma mark - Description method

- (NSString *)description {
  return [[DBFILESWriteModeSerializer serialize:self] description];
}

#pragma mark - Copyable method

- (instancetype)copyWithZone:(NSZone *)zone {
#pragma unused(zone)
  /// object is immutable
  return self;
}

#pragma mark - Hash method

- (NSUInteger)hash {
  NSUInteger prime = 31;
  NSUInteger result = 1;

  switch (_tag) {
  case DBFILESWriteModeAdd:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteModeOverwrite:
    result = prime * result + [[self tagName] hash];
  case DBFILESWriteModeUpdate:
    result = prime * result + [self.update hash];
  }

  return prime * result;
}

#pragma mark - Equality method

- (BOOL)isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (!other || ![other isKindOfClass:[self class]]) {
    return NO;
  }
  return [self isEqualToWriteMode:other];
}

- (BOOL)isEqualToWriteMode:(DBFILESWriteMode *)aWriteMode {
  if (self == aWriteMode) {
    return YES;
  }
  if (self.tag != aWriteMode.tag) {
    return NO;
  }
  switch (_tag) {
  case DBFILESWriteModeAdd:
    return [[self tagName] isEqual:[aWriteMode tagName]];
  case DBFILESWriteModeOverwrite:
    return [[self tagName] isEqual:[aWriteMode tagName]];
  case DBFILESWriteModeUpdate:
    return [self.update isEqual:aWriteMode.update];
  }
  return YES;
}

@end

#pragma mark - Serializer Object

@implementation DBFILESWriteModeSerializer

+ (NSDictionary *)serialize:(DBFILESWriteMode *)valueObj {
  NSMutableDictionary *jsonDict = [[NSMutableDictionary alloc] init];

  if ([valueObj isAdd]) {
    jsonDict[@".tag"] = @"add";
  } else if ([valueObj isOverwrite]) {
    jsonDict[@".tag"] = @"overwrite";
  } else if ([valueObj isUpdate]) {
    jsonDict[@"update"] = valueObj.update;
    jsonDict[@".tag"] = @"update";
  } else {
    @throw([NSException exceptionWithName:@"InvalidTag"
                                   reason:@"Object not properly initialized. Tag has an unknown value."
                                 userInfo:nil]);
  }

  return jsonDict;
}

+ (DBFILESWriteMode *)deserialize:(NSDictionary *)valueDict {
  NSString *tag = valueDict[@".tag"];

  if ([tag isEqualToString:@"add"]) {
    return [[DBFILESWriteMode alloc] initWithAdd];
  } else if ([tag isEqualToString:@"overwrite"]) {
    return [[DBFILESWriteMode alloc] initWithOverwrite];
  } else if ([tag isEqualToString:@"update"]) {
    NSString *update = valueDict[@"update"];
    return [[DBFILESWriteMode alloc] initWithUpdate:update];
  } else {
    @throw([NSException
        exceptionWithName:@"InvalidTag"
                   reason:[NSString stringWithFormat:@"Tag has an invalid value: \"%@\".", valueDict[@".tag"]]
                 userInfo:nil]);
  }
}

@end
